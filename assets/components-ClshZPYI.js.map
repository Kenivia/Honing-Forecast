{"version":3,"file":"components-ClshZPYI.js","sources":["../../src/Frontend/components/CheckboxGrid.tsx","../../src/Frontend/components/Icon.tsx","../../src/Frontend/components/SpreadsheetGrid.tsx","../../src/Frontend/components/Graph.tsx"],"sourcesContent":["/*eslint no-unused-vars: 0*/\nimport './CheckboxGrid.css';\n\ntype Props = {\n    grid: boolean[][]\n    rows: number\n    cols: number\n    gridRef: React.RefObject<HTMLDivElement | null>\n    onGridMouseDown: (grid: 'top' | 'bottom', e: React.MouseEvent) => void\n    marquee: any\n    CELL_W: number\n    CELL_H: number\n    gridName: 'top' | 'bottom'   // NEW required prop\n    useGridInput?: boolean\n    numericInputs?: number[][]\n    onNumericInputChange?: (grid: 'top' | 'bottom', row: number, col: number, value: number) => void\n}\n\n// Helper function to convert touch event to mouse event\nfunction createMouseEventFromTouch(touchEvent: React.TouchEvent, type: 'mousedown' | 'mousemove' | 'mouseup'): React.MouseEvent {\n    const touch = touchEvent.touches[0] || touchEvent.changedTouches[0];\n    return {\n        ...touchEvent,\n        type,\n        clientX: touch.clientX,\n        clientY: touch.clientY,\n        button: 0, // Left mouse button\n        buttons: type === 'mousedown' ? 1 : (type === 'mouseup' ? 0 : 1),\n        preventDefault: touchEvent.preventDefault.bind(touchEvent),\n        stopPropagation: touchEvent.stopPropagation.bind(touchEvent),\n    } as unknown as React.MouseEvent;\n}\n\nexport default function CheckboxGrid({ grid, rows, cols, gridRef, onGridMouseDown, marquee, CELL_W, CELL_H, gridName, useGridInput = true, numericInputs, onNumericInputChange }: Props) {\n    const handleTouchStart = (e: React.TouchEvent) => {\n        // Only prevent default behavior for grid interactions\n        e.preventDefault();\n        const mouseEvent = createMouseEventFromTouch(e, 'mousedown');\n        onGridMouseDown(gridName, mouseEvent);\n    };\n\n    if (!useGridInput && numericInputs && onNumericInputChange) {\n        // Render numeric input mode - only show inputs for \"Gloves\" row (index 4) and \"Weapon\" row (index 5)\n        return (\n            <div\n                ref={gridRef as any}\n                style={{ display: 'grid', gridTemplateColumns: `repeat(${cols}, ${CELL_W}px)`, gap: 0 }}\n            >\n                {grid.flatMap((row, r) =>\n                    row.map((checked, c) => {\n                        const key = `${r}-${c}`\n\n                        // Only show inputs for Gloves row (4) and Weapon row (5)\n                        if (r === 4 || r === 5) {\n                            const inputValue = numericInputs[r === 4 ? 0 : 1][c] || 0\n                            return (\n                                <div key={key} className=\"checkbox-grid-item\" style={{ width: CELL_W, height: CELL_H }}>\n                                    <input\n                                        type=\"number\"\n                                        min=\"0\"\n                                        value={inputValue === 0 ? '' : inputValue}\n                                        onChange={(e) => {\n                                            const inputVal = e.target.value\n                                            // Allow empty string, interpret as 0\n                                            const value = inputVal === '' ? 0 : Math.max(0, parseInt(inputVal) || 0)\n                                            onNumericInputChange(gridName, r, c, value)\n                                        }}\n                                        className=\"numeric-grid-input\"\n                                        placeholder='0'\n                                        style={{\n                                            width: '100%',\n                                            height: '100%',\n                                            border: '1px solid var(--input-border)',\n                                            borderRadius: '2px',\n                                            background: 'var(--input-bg)',\n                                            color: 'var(--input-text)',\n                                            textAlign: 'center',\n                                            fontSize: '16px',\n                                            padding: '0',\n                                            margin: '0',\n                                            boxSizing: 'border-box',\n                                            overflow: 'hidden',\n                                            textOverflow: 'ellipsis'\n                                        }}\n                                    />\n                                </div>\n                            )\n                        } else {\n                            // Empty cells for other rows\n                            return (\n                                <div key={key} className=\"checkbox-grid-item\" style={{ width: CELL_W, height: CELL_H }}>\n                                    {/* Empty cell */}\n                                </div>\n                            )\n                        }\n                    })\n                )}\n            </div>\n        )\n    }\n\n    // Render checkbox mode (default)\n    return (\n        <div\n            ref={gridRef as any}\n            onMouseDown={(e) => onGridMouseDown(gridName, e)}\n            onTouchStart={handleTouchStart}\n            style={{ display: 'grid', gridTemplateColumns: `repeat(${cols}, ${CELL_W}px)`, gap: 0 }}\n        >\n            {grid.flatMap((row, r) =>\n                row.map((checked, c) => {\n                    const key = `${r}-${c}`\n\n                    // show marquee inversion only for the owning grid\n                    let inMarquee = false\n                    if (marquee.active && marquee.grid === gridName) {\n                        const r1 = Math.min(marquee.startR, marquee.endR)\n                        const r2 = Math.max(marquee.startR, marquee.endR)\n                        const c1 = Math.min(marquee.startC, marquee.endC)\n                        const c2 = Math.max(marquee.startC, marquee.endC)\n                        inMarquee = r >= r1 && r <= r2 && c >= c1 && c <= c2\n                    }\n\n                    return (\n                        <div key={key} title={`+${(gridName) === \"top\" ? c + 1 : (c + 1) * 10}`} className=\"checkbox-grid-item\" style={{ width: CELL_W, height: CELL_H }}>\n                            <input\n                                type=\"checkbox\"\n                                readOnly\n                                checked={inMarquee ? !marquee.initialState : checked}\n                                className=\"checkbox-grid-input\"\n                            />\n                        </div>\n                    )\n                })\n            )}\n        </div>\n    )\n}\n","import React from 'react'\r\n\r\ninterface IconProps {\r\n    iconName: string\r\n    size?: number\r\n    style?: React.CSSProperties\r\n    display_text?: string | null\r\n}\r\n\r\nconst IconMap: Record<string, string> = {\r\n    'Helmet': '/Honing-Forecast/Icons/Equipments/Helmet.webp',\r\n    'Shoulder': '/Honing-Forecast/Icons/Equipments/Shoulder.webp',\r\n    'Chest': '/Honing-Forecast/Icons/Equipments/Chest.webp',\r\n    'Pants': '/Honing-Forecast/Icons/Equipments/Pants.webp',\r\n    'Glove': '/Honing-Forecast/Icons/Equipments/Gloves.webp',\r\n    'Weapon': '/Honing-Forecast/Icons/Equipments/Weapon.webp',\r\n    'Red': '/Honing-Forecast/Icons/Materials/Red.webp',\r\n    'Blue': '/Honing-Forecast/Icons/Materials/Blue.webp',\r\n    'Leaps': '/Honing-Forecast/Icons/Materials/Leap.webp',\r\n    'Shards': '/Honing-Forecast/Icons/Materials/Shard.webp',\r\n    'Oreha': '/Honing-Forecast/Icons/Materials/Oreha.webp',\r\n    'Gold': '/Honing-Forecast/Icons/Materials/Gold.webp',\r\n    'Silver': '/Honing-Forecast/Icons/Materials/Silver.webp',\r\n    'Red juice': '/Honing-Forecast/Icons/Materials/Red juice.webp',\r\n    'Blue juice': '/Honing-Forecast/Icons/Materials/Blue juice.webp',\r\n    'Special leaps': '/Honing-Forecast/Icons/Materials/Special leap.webp',\r\n    'Forecast Icon': '/Honing-Forecast/forecast icon.webp',\r\n}\r\n\r\nexport default function Icon({ iconName: name, display_text: display_text = null, size = 20, style }: IconProps) {\r\n    const iconPath = IconMap[name]\r\n\r\n    if (!iconPath) {\r\n        return <span style={style}>{name}</span>\r\n    }\r\n\r\n    return (\r\n        <div style={{ display: 'flex', alignItems: 'center', gap: '6px', ...style }}>\r\n            <span>{display_text === null ? name : display_text}</span>\r\n            <img\r\n                src={iconPath}\r\n                alt={name}\r\n                style={{\r\n                    width: size,\r\n                    height: size,\r\n                    objectFit: 'contain'\r\n                }}\r\n                onError={(e) => {\r\n                    // Fallback to text if image fails to load\r\n                    console.log(\"EquipmentIcon: Error loading image from \" + iconPath, e)\r\n                    const target = e.target as HTMLImageElement\r\n                    target.style.display = 'none'\r\n                    const parent = target.parentElement\r\n                    if (parent) {\r\n                        parent.innerHTML = name\r\n                    }\r\n                }}\r\n            />\r\n\r\n        </div>\r\n    )\r\n}\r\n\r\n","import React, { useState, useRef, useEffect, useCallback } from 'react'\nimport Icon from './Icon.tsx'\n\ninterface SpreadsheetGridProps {\n    columnDefs: Array<{ headerName: string; field: string; editable: boolean; flex: number; cellStyle: any }>\n    labels: string[]\n    sheet_values: Record<string, string>\n    set_sheet_values: (_next: any) => void\n    readOnly?: boolean\n    secondaryValues?: Record<string, string>\n    setSecondaryValues?: (_next: any) => void\n}\n\ninterface Selection {\n    startRow: number\n    startCol: number\n    endRow: number\n    endCol: number\n}\n\nexport default function SpreadsheetGrid({ columnDefs, labels, sheet_values: budget_inputs, set_sheet_values: set_sheet_values, readOnly = false, secondaryValues, setSecondaryValues }: SpreadsheetGridProps) {\n    const [selection, setSelection] = useState<Selection | null>(null)\n    const [isSelecting, setIsSelecting] = useState(false)\n    const [_copiedData, setCopiedData] = useState<string[][] | null>(null)\n    const gridRef = useRef<HTMLDivElement | null>(null)\n\n    // pointer-down tracking so we can detect small drags vs clicks when starting in an input\n    const pointerDownRef = useRef<{\n        startX: number\n        startY: number\n        startRow: number\n        startCol: number\n        startedOnInput: boolean\n        moved: boolean\n    } | null>(null)\n\n    // keep old body user-select so we can restore it after drag\n    const prevUserSelectRef = useRef<string | undefined>(undefined)\n\n    // const labels = useMemo(() => labels, [])\n\n    // ---------- helpers ----------\n    const clamp = (v: number, max: number) => Math.min(Math.max(v, 0), max)\n    const clampCol = useCallback((v: number) => Math.min(Math.max(v, 0), Math.max(0, columnDefs.length - 1)), [columnDefs.length])\n\n    const isCellSelected = (rowIndex: number, colIndex: number) => {\n        if (!selection) return false\n        const { startRow, startCol, endRow, endCol } = selection\n        const minRow = Math.min(startRow, endRow)\n        const maxRow = Math.max(startRow, endRow)\n        const minCol = Math.min(startCol, endCol)\n        const maxCol = Math.max(startCol, endCol)\n\n        return rowIndex >= minRow && rowIndex <= maxRow && colIndex >= minCol && colIndex <= maxCol\n    }\n\n    const handleCellChange = (rowIndex: number, colIndex: number, value: string) => {\n        if (readOnly) return\n\n        const label = labels[rowIndex]\n        if (label) {\n            if (colIndex === 0) {\n                // Budget column - only allow non-negative integers, strip leading zeros\n                let cleanValue = value.replace(/[^0-9]/g, '')\n                cleanValue = cleanValue.replace(/^0+(?=\\d)/, '')\n                if (cleanValue.length > 10) {\n                    cleanValue = '999999999'\n                }\n                const next = { ...budget_inputs }\n                next[label] = cleanValue\n                set_sheet_values(next)\n            } else if (colIndex === 1 && setSecondaryValues && secondaryValues) {\n                // Gold value column - allow non-negative decimals while typing\n                // Keep digits and a single dot; don't strip leading/trailing zeros here\n                let clean = value.replace(/[^0-9.]/g, '')\n                const firstDot = clean.indexOf('.')\n                if (firstDot !== -1) {\n                    clean = clean.slice(0, firstDot + 1) + clean.slice(firstDot + 1).replace(/\\./g, '')\n                }\n                if (clean.length > 20) clean = clean.slice(0, 20)\n                const next = { ...secondaryValues }\n                next[label] = clean\n                setSecondaryValues(next)\n            }\n        }\n    }\n\n    const handleCellBlur = (rowIndex: number, colIndex: number) => {\n        const label = labels[rowIndex]\n        if (!label) return\n        if (colIndex === 1 && setSecondaryValues && secondaryValues) {\n            let val = secondaryValues[label] ?? ''\n            // normalize on blur: strip leading zeros in int part, trailing zeros in frac; drop dot if needed\n            let clean = String(val).replace(/[^0-9.]/g, '')\n            const firstDot = clean.indexOf('.')\n            let hadDot = firstDot !== -1\n            if (firstDot !== -1) {\n                clean = clean.slice(0, firstDot + 1) + clean.slice(firstDot + 1).replace(/\\./g, '')\n            }\n            let intPart = hadDot ? clean.slice(0, clean.indexOf('.')) : clean\n            let fracPart = hadDot ? clean.slice(clean.indexOf('.') + 1) : ''\n            intPart = intPart.replace(/^0+(?=\\d)/, '')\n            if (intPart === '' && (fracPart !== '' || hadDot)) intPart = '0'\n            fracPart = fracPart.replace(/0+$/g, '')\n            let normalized = intPart\n            if (fracPart.length > 0) normalized += '.' + fracPart\n            if (normalized.length > 20) normalized = normalized.slice(0, 20)\n            if (normalized !== (secondaryValues[label] ?? '')) {\n                const next = { ...secondaryValues }\n                next[label] = normalized\n                setSecondaryValues(next)\n            }\n        }\n    }\n\n    // ---------- capture mousedown (so drags that begin inside inputs are detected) ----------\n    useEffect(() => {\n        const grid = gridRef.current\n        if (!grid) return\n\n        const onMouseDownCapture = (e: MouseEvent) => {\n            // only handle left button drags\n            if (e.button !== 0) return\n\n            // find an ancestor cell that contains data-row\n            const target = e.target as HTMLElement | null\n            const cell = target?.closest('[data-row]') as HTMLElement | null\n            if (!cell) return\n\n            const rowIndex = clamp(Number(cell.dataset.row), labels.length - 1)\n            const colIndex = clampCol(Number(cell.dataset.col ?? '0'))\n\n            pointerDownRef.current = {\n                startX: e.clientX,\n                startY: e.clientY,\n                startRow: rowIndex,\n                startCol: colIndex,\n                startedOnInput: !!target?.closest('input,textarea'),\n                moved: false\n            }\n\n            setIsSelecting(true)\n            if (selection) {\n                setSelection(null)\n            }\n            else {\n                setSelection({\n                    startRow: rowIndex,\n                    startCol: colIndex,\n                    endRow: rowIndex,\n                    endCol: colIndex\n                })\n            }\n            // DO NOT call e.preventDefault() here — we want a plain click (no drag) to still focus the input for editing.\n        }\n\n        grid.addEventListener('mousedown', onMouseDownCapture, true) // capture phase\n        return () => grid.removeEventListener('mousedown', onMouseDownCapture, true)\n    }, [labels.length, clampCol, selection]) // reattach if ref changes\n\n    // ---------- mousemove + mouseup to update selection when dragging ----------\n    useEffect(() => {\n        const onMouseMove = (e: MouseEvent) => {\n            const pd = pointerDownRef.current\n            if (!pd) return\n\n            const dx = Math.abs(e.clientX - pd.startX)\n            const dy = Math.abs(e.clientY - pd.startY)\n            const movedNow = dx > 5 || dy > 5 // small threshold = click vs drag\n\n            if (movedNow && !pd.moved) {\n                pd.moved = true\n                // if user started the interaction inside an input, blur + disable user-select to stop text-select\n                if (pd.startedOnInput) {\n                    prevUserSelectRef.current = document.body.style.userSelect\n                    try {\n                        document.body.style.userSelect = 'none'\n                    } catch {\n                        // Ignore errors\n                    }\n                    // blur active element to avoid text caret/selection interfering with drag\n                    if (document.activeElement instanceof HTMLElement) {\n                        (document.activeElement as HTMLElement).blur()\n                    }\n                }\n            }\n\n            // determine cell under pointer\n            const el = document.elementFromPoint(e.clientX, e.clientY) as HTMLElement | null\n            const cell = el?.closest('[data-row]') as HTMLElement | null\n            if (cell) {\n                const row = clamp(Number(cell.dataset.row), labels.length - 1)\n                const col = clampCol(Number(cell.dataset.col ?? '0'))\n                setSelection(prev => prev ? { ...prev, endRow: row, endCol: col } : {\n                    startRow: row, startCol: col, endRow: row, endCol: col\n                })\n            }\n        }\n\n        const onMouseUp = () => {\n            // restore `user-select` if we changed it\n            if (pointerDownRef.current?.moved && prevUserSelectRef.current !== undefined) {\n                try {\n                    document.body.style.userSelect = prevUserSelectRef.current\n                } catch {\n                    // Ignore errors\n                }\n                prevUserSelectRef.current = undefined\n            }\n            pointerDownRef.current = null\n            setIsSelecting(false)\n        }\n\n        document.addEventListener('mousemove', onMouseMove)\n        document.addEventListener('mouseup', onMouseUp)\n        return () => {\n            document.removeEventListener('mousemove', onMouseMove)\n            document.removeEventListener('mouseup', onMouseUp)\n        }\n    }, [labels.length, clampCol])\n\n    // ---------- native copy / paste handlers using system clipboard ----------\n    useEffect(() => {\n        const onCopy = (e: ClipboardEvent) => {\n            // if editing an input/textarea, let native copy happen (don't override)\n            const active = document.activeElement as HTMLElement | null\n            if (active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA')) return\n\n            if (!selection) return\n\n            const { startRow, startCol, endRow, endCol } = selection\n            const minRow = Math.min(startRow, endRow)\n            const maxRow = Math.max(startRow, endRow)\n            const minCol = Math.min(startCol, endCol)\n            const maxCol = Math.max(startCol, endCol)\n\n            const rowsOut: string[] = []\n            for (let r = minRow; r <= maxRow; r++) {\n                const cols: string[] = []\n                for (let c = minCol; c <= maxCol; c++) {\n                    // this grid is 1 column, but keep general logic\n                    const label = labels[r]\n                    cols.push(budget_inputs[label] == \"\" ? '0' : budget_inputs[label])\n                }\n                rowsOut.push(cols.join('\\t')) // tab separated per row\n            }\n            const text = rowsOut.join('\\n')\n            if (e.clipboardData) {\n                e.clipboardData.setData('text/plain', text)\n                e.preventDefault()\n            } else if ((window as any).clipboardData) {\n                // IE fallback (unlikely needed)\n                (window as any).clipboardData.setData('Text', text)\n                e.preventDefault()\n            }\n            // store for internal paste if needed\n            setCopiedData(rowsOut.map(r => r.split('\\t')))\n        }\n\n        const onPaste = (e: ClipboardEvent) => {\n            if (readOnly) return\n\n            // if editing an input/textarea, let native paste happen\n            // const active = document.activeElement as HTMLElement | null\n            // if (active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA')) return\n\n            const text = e.clipboardData?.getData('text/plain') ?? ''\n            if (!text) return\n\n            // parse text into 2D array: rows by newline, columns by comma/tab/space\n            const parsedRows = text\n                .split(/[\\t, \\n]+/)\n                .map(r => r.trim())\n                .filter(Boolean)\n\n\n            // determine paste start: use selection start if present, otherwise use focused cell\n            let startRow = selection?.startRow ?? 0\n            if (!selection) {\n                const focused = document.activeElement as HTMLElement | null\n                const cell = focused?.closest('[data-row]') as HTMLElement | null\n                if (cell) {\n                    startRow = clamp(Number(cell.dataset.row), 0)\n                }\n            }\n\n            const newInputs = { ...budget_inputs }\n            for (let r = 0; r < parsedRows.length; r++) {\n\n                const targetRow = startRow + r\n                if (targetRow < labels.length) {\n                    // Clean the pasted value to only allow positive integers\n                    let cleanValue = parsedRows[r].trim().replace(/[^0-9]/g, '')\n                    cleanValue = cleanValue.replace(/^0+(?=\\d)/, '')\n                    if (cleanValue.length > 10) cleanValue = '999999999'\n                    newInputs[labels[targetRow]] = cleanValue\n                }\n\n            }\n            set_sheet_values(newInputs)\n            e.preventDefault()\n        }\n\n        document.addEventListener('copy', onCopy)\n        document.addEventListener('paste', onPaste)\n        return () => {\n            document.removeEventListener('copy', onCopy)\n            document.removeEventListener('paste', onPaste)\n        }\n    }, [selection, budget_inputs, labels, set_sheet_values, readOnly]) // re-register when selection or inputs change\n\n    // ---------- optional grid-level keyboard handler (keeps existing behavior when grid has focus) ----------\n    const handleKeyDown = (e: React.KeyboardEvent) => {\n        // keep earlier copy/paste handling as a fallback if you want it, but\n        // we primarily rely on native clipboard events above.\n        // if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'a') {\n        //     // Example: select all\n        //     e.preventDefault()\n        //     setSelection({\n        //         startRow: 0, startCol: 0, endRow: labels.length - 1, endCol: clampCol(columnDefs.length - 1)\n        //     })\n        //     return\n        // }\n\n        // Clear selected editable cells to 0 on Backspace/Delete for editable grids\n        if (!readOnly && (e.key === 'Backspace' || e.key === 'Delete')) {\n            if (!selection) return\n            e.preventDefault()\n\n            const { startRow, startCol, endRow, endCol } = selection\n            const minRow = Math.min(startRow, endRow)\n            const maxRow = Math.max(startRow, endRow)\n            const minCol = Math.min(startCol, endCol)\n            const maxCol = Math.max(startCol, endCol)\n\n            let nextBudgets = { ...budget_inputs }\n            let nextSecondary = secondaryValues ? { ...secondaryValues } : undefined\n\n            for (let r = minRow; r <= maxRow; r++) {\n                const label = labels[r]\n                for (let c = minCol; c <= maxCol; c++) {\n                    if (c === 0) {\n                        nextBudgets[label] = '0'\n                    } else if (c === 1 && nextSecondary) {\n                        // Only allow editing first 7 rows in second column\n                        if (r < 7) {\n                            nextSecondary[label] = '0'\n                        }\n                    }\n                }\n            }\n\n            set_sheet_values(nextBudgets)\n            if (setSecondaryValues && nextSecondary) {\n                setSecondaryValues(nextSecondary)\n            }\n        }\n    }\n\n    // ---------- render ----------\n    return (\n        <div\n            ref={gridRef}\n            onKeyDown={handleKeyDown}\n            tabIndex={0}\n            style={{\n                display: 'flex',\n                padding: 6,\n                outline: 'none',\n                minHeight: '200px'\n            }}\n        >\n            <div style={{ ...columnDefs[0], width: 50 }}>\n                {[\"\"].concat(labels).map((lab) => (\n                    <div\n                        key={lab}\n                        style={{\n                            height: 36,\n                            color: 'var(--text-secondary)',\n                            display: 'flex',\n                            alignItems: 'center',\n                            justifyContent: 'flex-end',\n                            paddingRight: 8,\n                            whiteSpace: 'nowrap',\n                            fontSize: 'var(--font-size-sm)',\n                            paddingTop: 8,\n                        }}\n                    >\n                        <Icon iconName={lab} size={28} />\n                    </div>\n                ))}\n            </div>\n\n            <div style={{ flex: 1 }}>\n                {/* Column headers (plain text, aligned) */}\n                <div style={{ display: 'grid', gridTemplateColumns: columnDefs.map(() => '1fr').join(' '), gap: 0, marginBottom: 4, height: 36 }}>\n                    {columnDefs.map((colDef, colIndex) => (\n                        <div key={`hdr-${colIndex}`} style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', color: 'var(--text-primary)', textWrap: \"nowrap\", fontWeight: 500, fontSize: 'var(--font-size-md)' }}>\n                            {colDef.headerName}\n                        </div>\n                    ))}\n                </div>\n\n                <div style={{ display: 'grid', gridTemplateColumns: columnDefs.map(() => '1fr').join(' '), gap: 0 }}>\n                    {labels.map((label, rowIndex) =>\n                        columnDefs.map((colDef, colIndex) => (\n                            <div\n                                key={`${label}-${colIndex}`}\n                                data-row={rowIndex}\n                                data-col={colIndex}\n                                style={{ height: 36, display: 'flex', alignItems: 'center' }}\n                                onMouseEnter={() => {\n                                    if (isSelecting && pointerDownRef.current) {\n                                        setSelection(prev => prev ? { ...prev, endRow: rowIndex, endCol: colIndex } : {\n                                            startRow: rowIndex, startCol: colIndex, endRow: rowIndex, endCol: colIndex\n                                        })\n                                    }\n                                }}\n                            >\n                                <input\n                                    type=\"text\"\n                                    readOnly={readOnly || (colIndex === 1 && rowIndex >= 7)}\n                                    value={colIndex === 0 ? (budget_inputs[label] ?? '') : (secondaryValues?.[label] ?? '')}\n                                    onChange={(e) => handleCellChange(rowIndex, colIndex, e.target.value)}\n                                    onKeyDown={(e) => { e.stopPropagation() }}\n                                    onBlur={() => handleCellBlur(rowIndex, colIndex)}\n                                    onFocus={() => {\n                                        setSelection({\n                                            startRow: rowIndex,\n                                            startCol: colIndex,\n                                            endRow: rowIndex,\n                                            endCol: colIndex\n                                        })\n                                    }}\n                                    style={{\n                                        width: \"100px\",\n                                        height: '100%',\n                                        padding: '6px 8px',\n                                        border: '1px solid var(--border-accent)',\n                                        background: isCellSelected(rowIndex, colIndex) ?\n                                            ((readOnly || (colIndex === 1 && rowIndex >= 7)) ? 'var(--grid-cell-selected-readonly)' : 'var(--grid-cell-selected)') :\n                                            (typeof colDef.cellStyle === 'function' ? colDef.cellStyle({ value: colIndex === 0 ? (budget_inputs[label] ?? '') : (secondaryValues?.[label] ?? '') })?.backgroundColor || 'transparent' : colDef.cellStyle?.background || 'transparent'),\n                                        color: (readOnly || (colIndex === 1 && rowIndex >= 7)) ?\n                                            'var(--grid-cell-text-readonly)' :\n                                            (typeof colDef.cellStyle === 'function' ? colDef.cellStyle({ value: colIndex === 0 ? (budget_inputs[label] ?? '') : (secondaryValues?.[label] ?? '') })?.color || 'var(--grid-cell-text)' : colDef.cellStyle?.color || 'var(--grid-cell-text)'),\n                                        fontSize: 'var(--font-size-sm)',\n                                        outline: 'none',\n                                        boxSizing: 'border-box',\n                                        cursor: (readOnly || (colIndex === 1 && rowIndex >= 7)) ? 'default' : 'text',\n                                        opacity: (colIndex === 1 && rowIndex >= 7) ? 0.5 : 1\n                                    }}\n                                    placeholder=\"0\"\n                                />\n                            </div>\n                        ))\n                    )}\n                </div>\n            </div>\n        </div >\n    )\n}\n","import React, { useMemo, useState, useCallback, useRef } from 'react'\nimport { XYChart, AnimatedAxis, AnimatedGrid, AnimatedLineSeries, Tooltip, darkTheme } from '@visx/xychart'\nimport { localPoint } from '@visx/event'\nimport { remapCountsToLockedXAxis } from '../features/honing_forecast/HistogramUtils.ts'\nconst plotLeft = 50, plotRight = 50, plotTop = 50, plotBottom = 50\nconst GRID_COUNT = 10\ntype GraphProps = {\n    title?: string\n    labels: string[] // length 7\n    counts?: number[][] | null // 7 x 1000 (or undefined while loading)\n    mins?: number[] | null // length 7\n    maxs?: number[] | null // length 7\n    width?: number\n    height?: number\n    // pointOfInterestBucket?: number | null // 0..999 or null\n    // displayMode?: 'probability' | 'cost'\n    budgets?: number[] | null\n    additionalBudgets?: number[] | null // Additional set of budget points for second POI\n    hasSelection?: boolean\n    isLoading?: boolean\n    cumulative?: boolean\n    // Lock x-axis props\n    lockXAxis?: boolean\n    lockedMins?: number[] | null\n    lockedMaxs?: number[] | null\n}\n\ntype Point = { x: number, y: number }\n\nconst SERIES_COLORS_VARS: string[] = [\n    'var(--series-red)',\n    'var(--series-blue)',\n    'var(--series-leaps)',\n    'var(--series-shards)',\n    'var(--series-oreha)',\n    'var(--series-gold)',\n    'var(--series-silver)',\n]\n\nfunction formatSig3(n: number, place: number = 3): string {\n    if (!isFinite(n)) return ''\n\n    const abs = Math.abs(n)\n    let suffix = ''\n    let divisor = 1\n\n    if (abs >= 1_000_000_000) {\n        suffix = 'B'\n        divisor = 1_000_000_000\n    } else if (abs >= 1_000_000) {\n        suffix = 'M'\n        divisor = 1_000_000\n    } else if (abs >= 1_000) {\n        suffix = 'K'\n        divisor = 1_000\n    }\n\n    const scaled = n / divisor\n\n    // keep `place` significant figures, but trim trailing zeros\n    let s = parseFloat(\n        Number(scaled.toFixed(place)).toPrecision(place)\n    ).toLocaleString('en-US', {\n        minimumFractionDigits: 1, // show decimals for small K/M/B\n        maximumFractionDigits: place\n    })\n\n    return s + suffix\n}\n\n/**\n * Calculates the optimal number of decimal places for rounding based on cumulative percentage and data size.\n * The function finds the smallest integer n where |1-cumpct| < 1/10^n, \n * but caps n such that 10^(n+1) <= data_size.\n * \n * @param cumpct - The cumulative percentage (0-100)\n * @param data_size - The total number of data points\n * @returns The number of decimal places to use for rounding\n */\nfunction calculateDecimalPlaces(cumpct: number, data_size: number): number {\n    // Convert cumpct from percentage to decimal (0-1)\n    const cumPctDecimal = cumpct / 100;\n\n    // Calculate the difference from 1\n    const diff = Math.abs(1 - cumPctDecimal);\n    if (diff == 0) { return 0 }\n\n    // Find the smallest n where diff < 1/10^n\n    // This means n > -log10(diff), so n = Math.ceil(-log10(diff))\n    let n = Math.ceil(-Math.log10(diff));\n\n    // Cap n such that 10^(n+1) <= data_size\n    // This means n+1 <= log10(data_size), so n <= log10(data_size) - 1\n    const maxN = Math.floor(Math.log10(data_size)) - 2;\n\n    // Ensure n is at least 0 and at most maxN\n    n = Math.max(0, Math.min(n, maxN));\n\n    return n;\n}\n\nfunction to_step(arr: number[]): number[] {\n    const n = arr.length;\n    if (n === 0) return [];\n\n    // find last non-zero index\n    let lastNonZero = -1;\n    for (let i = 0; i < n; i++) {\n        if (arr[i] !== 0) lastNonZero = i;\n    }\n\n    const out: number[] = [];\n    let cur = 0;\n    let extraUsed = true; // whether we've used the \"one extra repeat\" after lastNonZero\n\n    if (lastNonZero === -1) {\n        // array is all zeros — return zeros\n        return new Array(n).fill(0);\n    }\n\n    for (let i = 0; i < n; i++) {\n        if (arr[i] !== 0) {\n            // normal non-zero — update current value\n            cur = arr[i];\n            // if this is the last non-zero, reset the extraUsed flag so we can allow one extra repeat\n            if (i === lastNonZero) extraUsed = false;\n        } else {\n            // arr[i] is zero\n            if (i > lastNonZero) {\n                // we're past the last non-zero entry in the input\n                if (!extraUsed) {\n                    // allow one extra repeat of the last non-zero value\n                    cur = arr[lastNonZero];\n                    extraUsed = true;\n                } else {\n                    // after the one extra repeat, force zero\n                    cur = 0;\n                }\n            }\n            // else: we're between non-zero values earlier in the array -> keep cur (carry forward)\n        }\n\n        out.push(cur);\n    }\n\n    return out;\n}\nfunction to_step_points(points: Point[]): Point[] {\n    const ys = points.map(p => p.y);      // extract y values\n    const stepped = to_step(ys);          // reuse our to_step function\n    // console.log(\"stepped\", ys, stepped)\n    return points.map((p, i) => ({ x: p.x, y: stepped[i] }));\n}\n\nfunction Graph({ title, labels, counts, mins, maxs, width = 640, height = 320, budgets = null, additionalBudgets = null, hasSelection = false, isLoading = false, cumulative = true, lockXAxis = false, lockedMins = null, lockedMaxs = null }: GraphProps) {\n    const [visible, setVisible] = useState<boolean[]>(() => [true, true, false, false, false, true, false])\n    const [hoverSeries, setHoverSeries] = useState<number | null>(null)\n    const [hoverBucket, setHoverBucket] = useState<number | null>(null)\n    const chartRef = useRef<HTMLDivElement | null>(null)\n\n    // Create stable pointer handler\n    const handleSeriesPointerMove = useCallback((idx: number) => () => {\n        setHoverSeries(idx)\n    }, [setHoverSeries])\n\n    // Compute \"effective\" inputs: if lockXAxis is on we use the locked snapshots for axis range\n    // and remap incoming counts to those locked ranges when lockedMax > incoming newMax.\n    const effectiveCounts: number[][] | null = useMemo(() => {\n        if (!counts) return null;\n        if (!lockXAxis || !lockedMaxs) return counts;\n        // remap using lockedMaxs vs incoming maxs\n        const remapped = remapCountsToLockedXAxis(counts, maxs, lockedMaxs);\n        // console.log('Lock x-axis enabled:', { lockXAxis, lockedMaxs, maxs, originalCounts: counts, remappedCounts: remapped });\n        return remapped;\n    }, [counts, lockXAxis, lockedMaxs, maxs]);\n\n    const effectiveMins: number[] | null = useMemo(() => {\n        if (!lockXAxis || !lockedMins) return mins ?? null;\n        // console.log('Using locked mins:', { lockXAxis, lockedMins, originalMins: mins });\n        return lockedMins;\n    }, [lockXAxis, lockedMins, mins]);\n\n    const effectiveMaxs: number[] | null = useMemo(() => {\n        if (!lockXAxis || !lockedMaxs) return maxs ?? null;\n        // console.log('Using locked maxs:', { lockXAxis, lockedMaxs, originalMaxs: maxs });\n        return lockedMaxs;\n    }, [lockXAxis, lockedMaxs, maxs]);\n\n    const bucketLen = effectiveCounts?.[0]?.length || counts?.[0]?.length || 1000\n    const data_size = Math.max(...Array.from({ length: 7 }, (_, i) =>\n        (effectiveCounts ?? counts)?.[i]?.reduce((partialSum, a) => partialSum + a, 0))) || 1;\n\n    // Drop any series where all frequency falls in a single bucket (<=1 positive bin)\n    const keepMask: boolean[] = useMemo(() => {\n        const srcCounts = effectiveCounts ?? counts;\n        if (!srcCounts) return new Array(7).fill(false)\n        return srcCounts.map(series => {\n            let positiveBins = 0\n            for (let i = 0; i < series.length && positiveBins <= 1; i++) if (series[i] > 0) positiveBins++\n            return positiveBins > 1\n        })\n    }, [effectiveCounts, counts])\n\n    const cdfSeries: number[][] | null = useMemo(() => {\n        const src = effectiveCounts ?? counts;\n        if (!src) return null\n        return src.map(series => {\n            const total = series.reduce((a, b) => a + b, 0) || 1\n            let acc = 0\n            const out = new Array(series.length)\n            for (let i = 0; i < series.length; i++) {\n                acc += series[i]\n                out[i] = acc / total\n            }\n            return out\n        })\n    }, [effectiveCounts, counts])\n\n    const normalizedCounts: number[][] | null = useMemo(() => {\n        const src = effectiveCounts ?? counts;\n        if (!src) return null\n        const denom = data_size || 1\n        return src.map(series => series.map(v => v / denom))\n    }, [effectiveCounts, counts, data_size])\n\n    const dataSeries: Point[][] = useMemo(() => {\n        // console.log(\"Effective counts\", effectiveCounts)\n        const srcCounts = effectiveCounts ?? counts;\n        if (!srcCounts) return [] as Point[][]\n        const source = cumulative && cdfSeries ? cdfSeries : (normalizedCounts || srcCounts)\n        let out: Point[][] = Array.from({ length: source.length }, () => []);\n        for (let i = 0; i < source.length; i++) {\n            let first = true;\n            let prev: number | null = null;\n            for (let b = 0; b < source[i].length; b++) {\n\n                out[i].push({ x: b, y: source[i][b] })\n                first = false;\n            }\n            if (first) {\n                out[i] = [{ x: 0, y: 0 }]\n            }\n            else {\n                out[i].push({ x: source[i].length, y: (prev ?? source[i][source[i].length - 1]) })\n            }\n        }\n        return out\n    }, [effectiveCounts, counts, cumulative, cdfSeries, normalizedCounts])\n\n    const yMax: number = useMemo(() => {\n\n        if (!dataSeries) return 0\n        if (cumulative) return 1\n        // const denom = data_size || 1\n        let m = 0\n\n        for (let i = 0; i < dataSeries.length; i++) {\n            if (!visible[i] || !keepMask[i]) continue\n            let this_series = to_step_points(dataSeries[i])\n            for (let j = 0; j < dataSeries[i].length; j++) { m = Math.max(m, this_series[j].y); }\n        }\n        // console.log(m, data_size, dataSeries, ind)\n        return m\n    }, [dataSeries, visible, keepMask, cumulative])\n\n    // --- New: detect whether incoming counts contain data outside (to the right of) the effective x-axis ---\n    // i.e. when incoming newMax > effectiveMax AND counts beyond that cutoff are non-zero\n    const hasUnplottedPoints: boolean = useMemo(() => {\n        // Only relevant if we have incoming counts and effective (locked) maxs\n        if (!counts || !maxs || !effectiveMaxs) return false;\n        const nSeries = counts.length;\n        for (let i = 0; i < nSeries; i++) {\n            const seriesCounts = counts[i];\n            const incomingMax = maxs[i];\n            const effectiveMax = effectiveMaxs[i];\n            if (incomingMax == null || effectiveMax == null) continue;\n            // If effectiveMax already >= incomingMax, nothing is truncated\n            if (effectiveMax >= incomingMax) continue;\n\n            // compute incoming bucket width\n            const nBuckets = seriesCounts?.length || bucketLen || 1;\n            // protect against division by zero\n            if (!isFinite(incomingMax) || incomingMax <= 0) {\n                // can't reason about ranges; skip this series\n                continue;\n            }\n            const incomingBin = incomingMax / nBuckets;\n            // first bucket index whose start >= effectiveMax:\n            // bucket j start = j * incomingBin. We want j s.t. j * incomingBin >= effectiveMax\n            // so j >= effectiveMax / incomingBin. Use Math.ceil to get the first index that lies fully >= effectiveMax.\n            const cutoffIndex = Math.max(0, Math.ceil(effectiveMax / incomingBin));\n\n            if (cutoffIndex < seriesCounts.length) {\n                // check if any count beyond cutoffIndex is positive\n                for (let b = cutoffIndex; b < seriesCounts.length; b++) {\n                    if ((seriesCounts[b] ?? 0) > 0) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }, [counts, maxs, effectiveMaxs, bucketLen]);\n\n    // const onLegendToggle = (i: number) => setVisible(v => v.map((b, idx) => idx === i ? !b : b))\n\n    const sortedVisibleIndices: number[] = useMemo(() => {\n        const base = labels.map((_, i) => i).filter(i => visible[i] && keepMask[i])\n        if (hoverSeries == null) return base\n        return base.filter(i => i !== hoverSeries).concat([hoverSeries])\n    }, [labels, visible, hoverSeries, keepMask])\n\n    const xAccessor = (d: Point) => { return d.x }\n    const yAccessor = (d: Point) => d.y\n\n    const handleMouseMove = useCallback((ev: React.MouseEvent<HTMLDivElement>) => {\n        const srcCounts = effectiveCounts ?? counts;\n        if (!srcCounts) return\n        const p = localPoint(ev)\n        const innerW = Math.max(1, width - plotLeft - plotRight)\n        const innerH = height - plotTop - plotBottom\n        const x = Math.min(Math.max((p?.x ?? 0) - plotLeft, 0), innerW)\n        const bucket = Math.min(bucketLen - 1, Math.round((x / innerW) * (bucketLen)))\n        // choose series with closest y to cursor vertically if possible; otherwise pick the highest y\n        const src = cumulative && cdfSeries ? cdfSeries : (normalizedCounts || srcCounts)\n        const denomY = Math.max(1e-9, yMax)\n        const ys = src.map((s, i) => ({ i, y: to_step(s)[bucket] / denomY * innerH, vis: visible[i] && keepMask[i] }))\n        const visibleYs = ys.filter(o => o.vis)\n        if (visibleYs.length === 0) { setHoverSeries(null); return }\n        // use highest y bucket as proxy for nearest vertically\n        const actual_y = innerH + plotBottom - p.y\n        const best = visibleYs.reduce((a, b) => Math.abs(a.y - actual_y) < Math.abs(b.y - actual_y) ? a : b)\n        setHoverSeries(best.i)\n        setHoverBucket(bucket)\n    }, [effectiveCounts, counts, visible, keepMask, bucketLen, width, height, yMax, cdfSeries, normalizedCounts, cumulative])\n\n    const handleMouseLeave = () => { setHoverSeries(null); setHoverBucket(null) }\n\n    const fallbackSeries = useMemo(() => {\n        if (hoverSeries != null && keepMask[hoverSeries]) return hoverSeries\n        const goldIdx = labels.indexOf('Gold')\n        if (goldIdx >= 0 && keepMask[goldIdx] && visible[goldIdx]) return goldIdx\n        const first = labels.map((_, i) => i).find(i => keepMask[i] && visible[i])\n        return first ?? null\n    }, [hoverSeries, labels, keepMask, visible])\n\n    const hoverColor = fallbackSeries != null ? SERIES_COLORS_VARS[fallbackSeries] : 'var(--text-secondary)'\n\n    // bottom axis tick values and formatter based on hovered series\n    const tickVals = useMemo(() => {\n        // const last = bucketLen - 1\n        // if (maxs) {\n        let out = Array.from({ length: GRID_COUNT + 1 }, (_, i) => Math.min(bucketLen, Math.round(bucketLen * i / (GRID_COUNT))))\n        return out\n        // }\n        // else {\n        //     return Array(GRID_COUNT)\n        // }\n\n    }, [bucketLen])\n    const bottomTickFormat = useCallback((val: any) => {\n        if (fallbackSeries == null || !effectiveMins || !effectiveMaxs) return formatSig3(val)\n\n        const min = effectiveMins[fallbackSeries]\n        const max = effectiveMaxs[fallbackSeries]\n        const bucketIdx = typeof val === 'number' ? val : Number(val)\n        const width = (max - min) / bucketLen\n        const mid = min + (bucketIdx) * width\n        return formatSig3(mid)\n    }, [fallbackSeries, effectiveMins, effectiveMaxs, bucketLen])\n\n\n    const anyVisible = useMemo(() => labels.some((_, i) => visible[i] && keepMask[i]), [labels, visible, keepMask])\n\n    // Memoize the AnimatedLineSeries nodes\n    const lineSeriesNodes = useMemo(() => {\n        return sortedVisibleIndices.map((seriesIdx) => (\n            <AnimatedLineSeries\n                key={labels[seriesIdx]}\n                dataKey={labels[seriesIdx]}\n                data={to_step_points(dataSeries[seriesIdx]) || []}\n                xAccessor={xAccessor}\n                yAccessor={yAccessor}\n                stroke={SERIES_COLORS_VARS[seriesIdx]}\n                strokeWidth={hoverSeries === seriesIdx ? 4 : 1.5}\n                opacity={1}\n                onPointerMove={handleSeriesPointerMove(seriesIdx)}\n            />\n        ));\n    }, [sortedVisibleIndices, dataSeries, hoverSeries, labels, handleSeriesPointerMove]);\n\n    // Memoize Points Of Interest (POI)\n    const poiNodes = useMemo(() => {\n        const srcCounts = effectiveCounts ?? counts;\n        if (!srcCounts || !anyVisible) return null;\n        const innerW = width - plotLeft - plotRight;\n        const innerH = height - plotTop - plotBottom;\n        const elems: React.ReactElement[] = [];\n\n        const renderFor = (budgetData: number[] | null, keyPrefix: string, circleRadius = 7, strokeColor = \"#000\") => {\n            if (!budgetData) return;\n            labels.forEach((_, i) => {\n                if (!visible[i] || !keepMask[i]) return;\n                const range = Math.max(1e-9, ((effectiveMaxs![i] - effectiveMins![i])));\n                const frac = (budgetData[i] - effectiveMins![i]) / range;\n                let bucket_idx = Math.max(0, Math.min(bucketLen, Math.floor(frac * (bucketLen))));\n                const cx = plotLeft + (bucket_idx / Math.max(1, bucketLen)) * innerW;\n                bucket_idx = Math.min(bucket_idx, bucketLen - 1)\n                const seriesVals = cumulative && cdfSeries ? cdfSeries[i] : ((normalizedCounts && normalizedCounts[i]) || srcCounts[i]);\n                const denomY2 = Math.max(1e-9, yMax);\n                // console.log(seriesVals)\n                const cy = plotTop + innerH - to_step(seriesVals)[bucket_idx] / denomY2 * innerH;\n                const labelText = formatSig3(budgetData[i]);\n                const boxW = Math.max(16, labelText.length * 8);\n                const boxH = 18;\n\n                elems.push(\n                    <g key={`${keyPrefix}-${i}`}>\n                        <circle cx={cx} cy={cy} r={circleRadius} fill={SERIES_COLORS_VARS[i]} stroke={strokeColor} strokeWidth={2} />\n                        <rect x={cx + 6} y={cy - boxH - 4} width={boxW} height={boxH} fill=\"rgba(0,0,0,0.5)\" rx={3} ry={3} />\n                        <text x={cx + 10} y={cy - 8} fill={SERIES_COLORS_VARS[i]} fontSize={12}>{labelText}</text>\n                    </g>\n                );\n            });\n        };\n\n        renderFor(budgets, \"poi-primary\", 5, \"#000\");\n        renderFor(additionalBudgets, \"poi-additional\", 7, \"var(--bright-green)\");\n\n        return elems.length ? <g>{elems}</g> : null;\n    }, [budgets, additionalBudgets, effectiveCounts, counts, anyVisible, visible, keepMask, width, height, bucketLen, effectiveMins, effectiveMaxs, cdfSeries, normalizedCounts, cumulative, yMax, labels]);\n\n    // Memoize hover marker computation\n    const hoverMarker = useMemo(() => {\n        const srcCounts = effectiveCounts ?? counts;\n        if (fallbackSeries == null || hoverBucket == null || !srcCounts || !visible[fallbackSeries] || !keepMask[fallbackSeries]) return null;\n        const innerW = width - plotLeft - plotRight;\n        const innerH = height - plotTop - plotBottom;\n        const cx = plotLeft + (hoverBucket / Math.max(1, bucketLen)) * innerW;\n        let bucket_idx = Math.min(hoverBucket, bucketLen - 1)\n        const hoverSeriesVals = cumulative && cdfSeries ? cdfSeries[fallbackSeries] : ((normalizedCounts && normalizedCounts[fallbackSeries]) || srcCounts[fallbackSeries]);\n        const denomY3 = Math.max(1e-9, yMax);\n        const cy = plotTop + innerH - (to_step(hoverSeriesVals)[bucket_idx] / denomY3) * innerH;\n        return { cx, cy, series: fallbackSeries };\n    }, [fallbackSeries, hoverBucket, effectiveCounts, counts, visible, keepMask, cumulative, cdfSeries, normalizedCounts, bucketLen, width, height, yMax]);\n\n    return (\n        <div style={{ display: 'flex', flexDirection: 'column', gap: 8, padding: 16, borderRadius: 16, backgroundColor: 'var(--bg-tertiary)' }} onMouseMove={handleMouseMove} onMouseLeave={handleMouseLeave}>\n            {title ? (\n                <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>\n                    <div style={{ color: 'var(--text-primary)', fontSize: \"var(--font-size-lg)\", fontWeight: 600 }}>{title}</div>\n                    {lockXAxis && effectiveMaxs && fallbackSeries != null ? (\n                        <div\n                            role=\"status\"\n                            aria-live=\"polite\"\n                            title=\"Graph may look a bit wonky in some cases, unlock x-axis to get a cleaner graph\"\n                            style={{\n                                display: 'inline-flex',\n                                alignItems: 'center',\n                                gap: 6,\n                                background: 'var(--warning-bg)',\n                                color: 'white',\n                                padding: '4px 8px',\n                                borderRadius: 8,\n                                fontSize: 12,\n                                border: '1px solid var(--warning-border)'\n                            }}\n                        >\n                            x-axis locked at {formatSig3(effectiveMaxs[fallbackSeries])}\n                            <span style={{ color: SERIES_COLORS_VARS[fallbackSeries] }}>{labels[fallbackSeries].padEnd(Math.max(...labels.slice(0, 7).map(l => l.length)), ' ')}</span>\n                            {hasUnplottedPoints && (\n                                <span>- Some trials used more and were not plotted</span>\n                            )}\n                        </div>\n                    ) : null}\n                </div>\n            ) : null}\n            <div ref={chartRef}>\n                <XYChart\n                    height={height}\n                    width={width}\n                    xScale={{ type: 'linear', domain: [0, Math.max(0, bucketLen)] }}\n                    yScale={{ type: 'linear', domain: cumulative ? [0, 1] : [0, Math.max(1e-6, yMax)] }}\n                    theme={darkTheme}\n                >\n                    {/* Remove horizontal grid and y-axis; add vertical grid lines */}\n                    <AnimatedGrid columns numTicks={GRID_COUNT} rows={false} />\n                    <AnimatedAxis orientation=\"bottom\"\n                        label={'Normalized mats cost(0 to pity)'}\n                        tickValues={tickVals}\n                        tickFormat={bottomTickFormat as any} tickLabelProps={() => ({ fill: hoverColor, fontSize: 11, angle: -0 })} />\n                    {/* Y axis with custom ticks */}\n                    <AnimatedAxis\n                        orientation=\"left\"\n                        label={cumulative ? 'Cumulative Probability of Success' : 'Probability distribution'}\n                        tickValues={(() => {\n                            if (cumulative) {\n                                // 0..1 inclusive at 0.1 steps\n                                const vals: number[] = []\n                                for (let i = 0; i <= 10; i++) vals.push(i / 10)\n                                return vals\n                            } else {\n                                const vals: number[] = []\n                                // let sum = counts[0].reduce((partialSum, a) => partialSum + a, 0);\n                                for (let i = 0; i <= 10; i++) vals.push(yMax * i / 10)\n                                return vals\n                            }\n                        })()}\n                        tickFormat={(val: any) => {\n                            // if (cumulative) {\n                            const n = typeof val === 'number' ? val : Number(val)\n                            return (n * 100).toFixed(0) + \"%\"\n                            // }\n                            // return formatSig3(typeof val === 'number' ? val * 100 : Number(val * 100)) + \"%\"\n                        }}\n                        tickLabelProps={() => ({ fill: hoverColor, fontSize: 11 })}\n                    />\n                    {lineSeriesNodes}\n\n                    {/* Primary & additional POI */}\n                    {poiNodes}\n\n                    {/* Hover point snapped to selected series */}\n                    {hoverMarker && (\n                        <g>\n                            <circle cx={hoverMarker.cx} cy={hoverMarker.cy} r={4.5} fill={SERIES_COLORS_VARS[hoverMarker.series]} stroke=\"#fff\" strokeWidth={2} />\n                        </g>\n                    )}\n\n                    <Tooltip\n                        snapTooltipToDatumX\n                        snapTooltipToDatumY={true}\n                        showSeriesGlyphs={false}\n                        renderTooltip={() => {\n                            if (fallbackSeries == null || hoverBucket == null || !effectiveMins || !effectiveMaxs) return null\n                            const min = effectiveMins[fallbackSeries]\n                            const max = effectiveMaxs[fallbackSeries]\n                            const widthRange = Math.max(1e-9, max - min);\n                            const mid = min + (hoverBucket + 0.5) * (widthRange / bucketLen)\n                            const srcCounts = effectiveCounts ?? counts;\n                            const cumPctRaw = srcCounts[fallbackSeries].slice(0, hoverBucket + 1).reduce((partialSum, a) => partialSum + a, 0) / data_size * 100\n                            const decimalPlaces = calculateDecimalPlaces(cumPctRaw, data_size)\n                            const cumPct = cumPctRaw.toFixed(decimalPlaces)\n                            return (\n                                <div style={{ color: 'var(--text-primary)' }}>\n                                    <div style={{ color: SERIES_COLORS_VARS[fallbackSeries], fontWeight: 600 }}>{labels[fallbackSeries]}</div>\n                                    <div>In a room of 100 people,</div>\n                                    <div>{cumPct} used less than {formatSig3(mid, 3)} {labels[fallbackSeries]}</div>\n                                </div>\n                            )\n                        }}\n                    />\n                </XYChart>\n            </div>\n            {/* Legend */}\n            <div style={{ display: 'flex', flexWrap: 'wrap', gap: 10 }}>\n                {labels.map((lab, i) => keepMask[i] ? (\n                    <button\n                        key={lab}\n                        onClick={() => {\n                            // toggle visibility and bring to front by moving last in visible order\n                            setVisible(v => v.map((b, idx) => idx === i ? !b : b))\n                            if (i === hoverSeries && visible[i]) {\n                                setHoverSeries(null)\n                            }\n                            else {\n                                setHoverSeries(i)\n                            }\n\n                        }}\n                        style={{ display: 'flex', alignItems: 'center', gap: 6, background: 'transparent', border: '1px solid var(--border-secondary)', padding: '2px 6px', cursor: 'pointer', opacity: visible[i] ? 1 : 0.4 }}>\n                        <span style={{ width: 10, height: 10, background: SERIES_COLORS_VARS[i], display: 'inline-block' }} />\n                        <span style={{ color: 'var(--text-secondary)', fontSize: 12 }}>{lab}</span>\n                    </button>\n                ) : null)}\n            </div>\n\n            {!anyVisible && (\n                <div>\n                    <div style={{ color: 'var(--text-secondary)', fontSize: 50, alignSelf: 'center', justifySelf: 'center', marginTop: -200 }}>\n                        {hasSelection ? isLoading ? \"Loading...\" : 'Nothing to plot, couple possibilities:' : 'Nothing to plot, tick an upgrade!'}\n                    </div>\n                    <div style={{ fontSize: 12 }}>{isLoading && hasSelection ? \"Please allow up to ~5s, if it still doesnt load then gg\" : \"\"}</div>\n                    <div style={{ fontSize: 12 }}>{isLoading && hasSelection ? \"Also the first run is slower because it has to spin up WebAssembly\" : \"\"}</div>\n                    <div style={{ fontSize: 12 }}>{!isLoading && hasSelection ? \"1. All your ticks have 100% success rate(+1 to +3)\" : \"\"}</div>\n                    <div style={{ fontSize: 12 }}>{!isLoading && hasSelection ? \"2. The x-axis was locked at too high a value, so everything fell within the first pixel/tick.(Both situations are due to every point landing on the same x value)\" : \"\"}</div>\n                </div>\n            )}\n        </div>\n    )\n}\n\n// Export memoized component for performance\nexport default React.memo(Graph)\n"],"names":["createMouseEventFromTouch","touchEvent","type","touch","CheckboxGrid","grid","rows","cols","gridRef","onGridMouseDown","marquee","CELL_W","CELL_H","gridName","useGridInput","numericInputs","onNumericInputChange","handleTouchStart","e","mouseEvent","jsx","row","r","checked","c","key","inputValue","inputVal","value","inMarquee","r1","r2","c1","c2","IconMap","Icon","name","display_text","size","style","iconPath","jsxs","target","parent","SpreadsheetGrid","columnDefs","labels","budget_inputs","set_sheet_values","readOnly","secondaryValues","setSecondaryValues","selection","setSelection","useState","isSelecting","setIsSelecting","_copiedData","setCopiedData","useRef","pointerDownRef","prevUserSelectRef","clamp","v","max","clampCol","useCallback","isCellSelected","rowIndex","colIndex","startRow","startCol","endRow","endCol","minRow","maxRow","minCol","maxCol","handleCellChange","label","cleanValue","next","clean","firstDot","handleCellBlur","val","hadDot","intPart","fracPart","normalized","useEffect","onMouseDownCapture","cell","onMouseMove","pd","dx","dy","el","col","prev","onMouseUp","_a","onCopy","active","rowsOut","text","onPaste","parsedRows","focused","newInputs","targetRow","handleKeyDown","nextBudgets","nextSecondary","lab","colDef","_b","_c","_d","plotLeft","plotRight","plotTop","plotBottom","GRID_COUNT","SERIES_COLORS_VARS","formatSig3","n","place","abs","suffix","divisor","scaled","calculateDecimalPlaces","cumpct","data_size","cumPctDecimal","diff","maxN","to_step","arr","lastNonZero","i","out","cur","extraUsed","to_step_points","points","ys","p","stepped","Graph","title","counts","mins","maxs","width","height","budgets","additionalBudgets","hasSelection","isLoading","cumulative","lockXAxis","lockedMins","lockedMaxs","visible","setVisible","hoverSeries","setHoverSeries","hoverBucket","setHoverBucket","chartRef","handleSeriesPointerMove","idx","effectiveCounts","useMemo","remapCountsToLockedXAxis","effectiveMins","effectiveMaxs","bucketLen","_","partialSum","a","keepMask","srcCounts","series","positiveBins","cdfSeries","src","total","b","acc","normalizedCounts","denom","dataSeries","source","first","yMax","m","this_series","j","hasUnplottedPoints","nSeries","seriesCounts","incomingMax","effectiveMax","nBuckets","incomingBin","cutoffIndex","sortedVisibleIndices","base","xAccessor","d","yAccessor","handleMouseMove","ev","localPoint","innerW","innerH","x","bucket","denomY","visibleYs","s","o","actual_y","best","handleMouseLeave","fallbackSeries","goldIdx","hoverColor","tickVals","bottomTickFormat","min","bucketIdx","mid","anyVisible","lineSeriesNodes","seriesIdx","AnimatedLineSeries","poiNodes","elems","renderFor","budgetData","keyPrefix","circleRadius","strokeColor","range","frac","bucket_idx","cx","seriesVals","denomY2","cy","labelText","boxW","boxH","hoverMarker","hoverSeriesVals","denomY3","l","XYChart","darkTheme","AnimatedGrid","AnimatedAxis","vals","Tooltip","widthRange","cumPctRaw","decimalPlaces","cumPct","Graph$1","React"],"mappings":"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"}