{"version":3,"file":"wasm-workers-CSWhRIRv.js","sources":["../../src/Frontend/worker_setup.ts"],"sourcesContent":["function makeId() {\r\n    // simple unique id\r\n    return Math.random().toString(36).slice(2) + Date.now().toString(36)\r\n}\r\n\r\nexport function SpawnWorker(payload, which_one) {\r\n    // adjust path if needed\r\n    const worker = new Worker(new URL(\"./js_to_wasm.ts\", import.meta.url), { type: \"module\" })\r\n    const id = makeId()\r\n\r\n    let settled = false\r\n    const promise = new Promise((resolve, reject) => {\r\n        const onMessage = (ev) => {\r\n            // only accept messages that are result messages with the same id\r\n            const msg = ev.data\r\n            if (msg && msg.type === \"result\" && msg.id === id) {\r\n                settled = true\r\n                worker.removeEventListener(\"message\", onMessage)\r\n                worker.removeEventListener(\"error\", onError)\r\n                resolve(msg.result)\r\n            } else {\r\n                // ignore unrelated messages (or you could expose them as events)\r\n            }\r\n        }\r\n        const onError = (err) => {\r\n            if (!settled) {\r\n                settled = true\r\n                worker.removeEventListener(\"message\", onMessage)\r\n                worker.removeEventListener(\"error\", onError)\r\n                reject(err)\r\n            }\r\n        }\r\n\r\n        worker.addEventListener(\"message\", onMessage)\r\n        worker.addEventListener(\"error\", onError)\r\n\r\n        // send the message including the id so worker can attach it to the response\r\n        try {\r\n            worker.postMessage({ id, payload, which_one })\r\n        } catch (e) {\r\n            // posting failed â€” clean up\r\n            worker.removeEventListener(\"message\", onMessage)\r\n            worker.removeEventListener(\"error\", onError)\r\n            reject(e)\r\n        }\r\n    })\r\n\r\n    // When the promise settles we'll terminate the worker for safety\r\n    const wrapped = promise.finally(() => {\r\n        try {\r\n            worker.terminate()\r\n        } catch (e) {\r\n            //\r\n        }\r\n    })\r\n\r\n    return { worker, promise: wrapped }\r\n}\r\n\r\nexport async function CallWorker(payload, which_one) {\r\n    const { worker, promise } = SpawnWorker(payload, which_one)\r\n    try {\r\n        const res = await promise\r\n        try {\r\n            worker.terminate()\r\n        } catch (e) {\r\n            //\r\n        }\r\n        return res\r\n    } catch (err) {\r\n        try {\r\n            worker.terminate()\r\n        } catch (e) {\r\n            //\r\n        }\r\n        throw err\r\n    }\r\n}\r\n"],"names":["makeId","SpawnWorker","payload","which_one","worker","id","settled","wrapped","resolve","reject","onMessage","ev","msg","onError","err","e"],"mappings":"AAAA,SAASA,GAAS,CAEd,OAAO,KAAK,OAAA,EAAS,SAAS,EAAE,EAAE,MAAM,CAAC,EAAI,KAAK,MAAM,SAAS,EAAE,CACvE,CAEO,SAASC,EAAYC,EAASC,EAAW,CAE5C,MAAMC,EAAS,IAAI,OAAO,IAAA,IAAA,iDAAA,YAAA,GAAA,EAA6C,CAAE,KAAM,QAAA,CAAU,EACnFC,EAAKL,EAAA,EAEX,IAAIM,EAAU,GAsCd,MAAMC,EArCU,IAAI,QAAQ,CAACC,EAASC,IAAW,CAC7C,MAAMC,EAAaC,GAAO,CAEtB,MAAMC,EAAMD,EAAG,KACXC,GAAOA,EAAI,OAAS,UAAYA,EAAI,KAAOP,IAC3CC,EAAU,GACVF,EAAO,oBAAoB,UAAWM,CAAS,EAC/CN,EAAO,oBAAoB,QAASS,CAAO,EAC3CL,EAAQI,EAAI,MAAM,EAI1B,EACMC,EAAWC,GAAQ,CAChBR,IACDA,EAAU,GACVF,EAAO,oBAAoB,UAAWM,CAAS,EAC/CN,EAAO,oBAAoB,QAASS,CAAO,EAC3CJ,EAAOK,CAAG,EAElB,EAEAV,EAAO,iBAAiB,UAAWM,CAAS,EAC5CN,EAAO,iBAAiB,QAASS,CAAO,EAGxC,GAAI,CACAT,EAAO,YAAY,CAAE,GAAAC,EAAI,QAAAH,EAAS,UAAAC,EAAW,CACjD,OAASY,EAAG,CAERX,EAAO,oBAAoB,UAAWM,CAAS,EAC/CN,EAAO,oBAAoB,QAASS,CAAO,EAC3CJ,EAAOM,CAAC,CACZ,CACJ,CAAC,EAGuB,QAAQ,IAAM,CAClC,GAAI,CACAX,EAAO,UAAA,CACX,MAAY,CAEZ,CACJ,CAAC,EAED,MAAO,CAAE,OAAAA,EAAQ,QAASG,CAAA,CAC9B"}