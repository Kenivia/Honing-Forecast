{"version":3,"file":"gamba-B7trnSaU.js","sources":["../../src/Frontend/features/honing_forecast/GambaInfoBox.tsx","../../src/Frontend/features/honing_forecast/GambaSelection.tsx","../../src/Frontend/features/honing_forecast/GambaLogic.tsx","../../src/Frontend/features/honing_forecast/GambaSection.tsx"],"sourcesContent":["import React from \"react\"\r\nimport { Upgrade, calculateCurrentChance, getTapCountRange } from \"./utils.ts\"\r\n\r\ninterface GambaInfoBoxProps {\r\n    upgradeArr: Upgrade[]\r\n    selectedUpgradeIndex: number | null\r\n    setUpgradeArr: React.Dispatch<React.SetStateAction<Upgrade[]>>\r\n    attemptTap: () => void\r\n    toggleAutoAttemptThisOne: () => void\r\n    toggleAutoAttempt: () => void\r\n    freeTap: () => void\r\n    isAutoAttempting: boolean\r\n    isAutoAttemptingThisOne: boolean\r\n    unfinishedNormalUpgrades: Upgrade[]\r\n    adv_hone_strategy: string\r\n}\r\n\r\nexport default function GambaInfoBox({\r\n    upgradeArr,\r\n    selectedUpgradeIndex,\r\n    setUpgradeArr,\r\n    attemptTap,\r\n    toggleAutoAttemptThisOne,\r\n    toggleAutoAttempt,\r\n    freeTap,\r\n    isAutoAttempting,\r\n    isAutoAttemptingThisOne,\r\n    unfinishedNormalUpgrades,\r\n    adv_hone_strategy\r\n}: GambaInfoBoxProps) {\r\n    const selectedUpgrade = selectedUpgradeIndex !== null ? upgradeArr[selectedUpgradeIndex] : null\r\n    const isFinished = selectedUpgrade?.is_finished ?? false\r\n\r\n    return (\r\n        <div style={{\r\n            width: 300,\r\n            padding: 15,\r\n            border: '1px solid var(--border-accent)',\r\n            borderRadius: '8px',\r\n            boxShadow: isFinished ? '0 0 10px var(--bright-green-glow), 0 0 20px var(--bright-green-glow)' : 'none'\r\n        }}>\r\n            <h4 style={{ margin: 0, marginBottom: 10 }}>\r\n                {upgradeArr[selectedUpgradeIndex] === undefined ? \"\" :\r\n                    upgradeArr[selectedUpgradeIndex].is_normal_honing ? '+' : 'Adv +'}{upgradeArr[selectedUpgradeIndex] === undefined ? \"\" : upgradeArr[selectedUpgradeIndex].is_normal_honing ? upgradeArr[selectedUpgradeIndex].upgrade_plus_num + 1 : (upgradeArr[selectedUpgradeIndex].upgrade_plus_num + 1) * 10} {upgradeArr[selectedUpgradeIndex] === undefined ? \"\" : upgradeArr[selectedUpgradeIndex].equipment_type}</h4>\r\n            {selectedUpgradeIndex !== null && upgradeArr[selectedUpgradeIndex] ? (\r\n                <>\r\n                    {upgradeArr[selectedUpgradeIndex].is_normal_honing ? (\r\n                        <>\r\n                            <div>Base Rate: {(upgradeArr[selectedUpgradeIndex].base_chance * 100).toFixed(2)}%</div>\r\n                            <div>Current Chance: {(calculateCurrentChance(upgradeArr[selectedUpgradeIndex]) * 100).toFixed(2)}%</div>\r\n\r\n                            <div>Artisan: {(upgradeArr[selectedUpgradeIndex].current_artisan * 100).toFixed(2)}%</div>\r\n                            <div>Trials: {upgradeArr[selectedUpgradeIndex].taps_so_far}</div>\r\n                            <div>Free Taps: {upgradeArr[selectedUpgradeIndex].free_taps_so_far}</div>\r\n                            <div>In a room of 100 people, you are less lucky than {((upgradeArr[selectedUpgradeIndex].cumulative_chance || 0) * 100).toFixed(0)} of them.</div>\r\n                        </>\r\n                    ) : (\r\n                        (() => {\r\n                            const rangeInfo = getTapCountRange(upgradeArr[selectedUpgradeIndex])\r\n                            return rangeInfo ? (\r\n                                <>\r\n                                    <div>\r\n                                        Tap Count Range: {rangeInfo.range}\r\n                                    </div>\r\n                                    <div>{\"In a room of 100 people, you are less lucky than \" + (upgradeArr[selectedUpgradeIndex].cumulative_chance * 100).toFixed(0) + \" of them.\"}</div>\r\n\r\n\r\n                                </>\r\n                            ) : null\r\n                        })()\r\n                    )}\r\n\r\n                    <div style={{ marginTop: 15, display: \"flex\", flexDirection: \"column\", gap: 8 }}>\r\n                        <label style={{ display: \"flex\", alignItems: \"center\", gap: 5 }}>\r\n                            <input\r\n                                type=\"checkbox\"\r\n                                title=\"This mode does not automatically use your juice, and you may go into juice debt, nobody can stop you\"\r\n                                checked={upgradeArr[selectedUpgradeIndex]?.use_juice ?? false}\r\n                                onChange={(e) => {\r\n                                    if (selectedUpgradeIndex !== null) {\r\n                                        setUpgradeArr(prev => {\r\n                                            const next = prev.slice()\r\n                                            next[selectedUpgradeIndex] = {\r\n                                                ...next[selectedUpgradeIndex],\r\n                                                use_juice: e.target.checked\r\n                                            }\r\n                                            return next\r\n                                        })\r\n                                    }\r\n                                }}\r\n                            />\r\n                            Use juice\r\n\r\n                        </label>\r\n                        {/* <div style={{ marginTop: -10, paddingLeft: 20, fontSize: \"var(--font-size-xs)\" }}> {(Number(budgetRemainingData[\"Red juice\"]) > 0 && upgradeArr[selectedUpgradeIndex]?.is_weapon) || (Number(budgetRemainingData[\"Blue juice\"]) > 0 && !upgradeArr[selectedUpgradeIndex]?.is_weapon) ? \"This mode does not automatically use your juice, and you may go into juice debt, nobody can stop you\" : \"\"}</div> */}\r\n                        <div> {!upgradeArr[selectedUpgradeIndex]?.is_normal_honing && (upgradeArr[selectedUpgradeIndex]?.use_juice != (adv_hone_strategy === \"Juice on grace\")) ? \"(Graph below is not updated by this tick)\" : \"\"}</div>\r\n                        <button\r\n                            onClick={attemptTap}\r\n                            disabled={upgradeArr[selectedUpgradeIndex]?.is_finished || isAutoAttempting || isAutoAttemptingThisOne}\r\n                            style={{\r\n                                padding: '5px 10px',\r\n                                opacity: upgradeArr[selectedUpgradeIndex]?.is_finished ? 0.5 : 1\r\n                            }}\r\n                        >\r\n                            {upgradeArr[selectedUpgradeIndex]?.is_finished ? \"Success!\" : \"Tap\"}\r\n                        </button>\r\n\r\n                        <button\r\n                            onClick={toggleAutoAttemptThisOne}\r\n                            disabled={isAutoAttempting || upgradeArr[selectedUpgradeIndex]?.is_finished || !upgradeArr[selectedUpgradeIndex]?.is_normal_honing}\r\n                            style={{\r\n                                padding: '5px 10px',\r\n                                backgroundColor: isAutoAttemptingThisOne ? 'var(--error-color)' : 'var(--btn-primary)',\r\n                                color: isAutoAttemptingThisOne ? 'white' : 'var(--text-primary)',\r\n                                border: isAutoAttemptingThisOne ? '2px solid var(--error-color)' : '1px solid var(--border-accent)',\r\n                                fontWeight: isAutoAttemptingThisOne ? 'bold' : 'normal',\r\n                                opacity: (isAutoAttempting || upgradeArr[selectedUpgradeIndex]?.is_finished || !upgradeArr[selectedUpgradeIndex]?.is_normal_honing) ? 0.5 : 1\r\n                            }}\r\n                        >\r\n                            {isAutoAttemptingThisOne ? 'Auto Tapping This...' : 'Auto Tap This One'}\r\n                        </button>\r\n\r\n                        <button\r\n                            onClick={toggleAutoAttempt}\r\n                            disabled={unfinishedNormalUpgrades.length <= 1}\r\n                            style={{\r\n                                padding: '5px 10px',\r\n                                backgroundColor: isAutoAttempting ? 'var(--error-color)' : 'var(--btn-primary)',\r\n                                color: isAutoAttempting ? 'white' : 'var(--text-primary)',\r\n                                border: isAutoAttempting ? '2px solid var(--error-color)' : '1px solid var(--border-accent)',\r\n                                fontWeight: isAutoAttempting ? 'bold' : 'normal',\r\n                                opacity: unfinishedNormalUpgrades.length <= 1 ? 0.5 : 1\r\n                            }}\r\n                        >\r\n                            {isAutoAttempting ? 'Auto Tapping...' : 'Auto Tap All'}\r\n                        </button>\r\n\r\n                        <button\r\n                            onClick={freeTap}\r\n                            disabled={upgradeArr[selectedUpgradeIndex]?.is_normal_honing === false || upgradeArr[selectedUpgradeIndex]?.is_finished || isAutoAttempting || isAutoAttemptingThisOne}\r\n                            style={{\r\n                                padding: '5px 10px',\r\n                                opacity: upgradeArr[selectedUpgradeIndex]?.is_normal_honing === false ? 0.5 : 1\r\n                            }}\r\n                        >\r\n                            Free Tap\r\n                        </button>\r\n                    </div>\r\n                </>\r\n            ) : (\r\n                <div style={{ color: 'var(--text-secondary)', fontStyle: 'italic' }}>\r\n                    Select an upgrade to begin\r\n                </div>\r\n            )}\r\n        </div>\r\n    )\r\n}\r\n","import React from \"react\"\r\nimport { Upgrade } from \"./utils.ts\"\r\n\r\ninterface GambaSelectionProps {\r\n    upgradeArr: Upgrade[]\r\n    sortedWithIndex: number[]\r\n    selectedUpgradeIndex: number | null\r\n    handleUpgradeSelection: (_index: number) => void\r\n    isAutoAttempting: boolean\r\n    isAutoAttemptingThisOne: boolean\r\n    tooltipHandlers: {\r\n        showUpgradeTooltip: (_upgrade: any, _costLabels: string[], _tapRecordCosts: number[], _x: number, _y: number) => void\r\n        hideTooltip: () => void\r\n        updateTooltipPosition: (_x: number, _y: number) => void\r\n    }\r\n}\r\n\r\n// Simple wrapper component for upgrade tooltips\r\ntype UpgradeTooltipProps = {\r\n    upgrade: Upgrade\r\n    children: React.ReactNode\r\n    tooltipHandlers: GambaSelectionProps['tooltipHandlers']\r\n}\r\n\r\nconst UpgradeTooltip = React.memo(function UpgradeTooltip({ upgrade, children, tooltipHandlers }: UpgradeTooltipProps) {\r\n    const costLabels = ['Red', 'Blue', 'Leaps', 'Shards', 'Oreha', \"Gold\", 'Silver', 'Red Juice', 'Blue Juice', 'Special Leaps']\r\n    const tapRecordCosts = React.useMemo(() => {\r\n        const costs = new Array(10).fill(0)\r\n        const taps = upgrade.taps_so_far ?? 0\r\n        const juiceTaps = upgrade.juice_taps_so_far ?? 0\r\n        const freeTaps = upgrade.free_taps_so_far ?? 0\r\n\r\n        // Regular costs multiplied by taps\r\n        for (let i = 0; i < 7; i++) {\r\n            costs[i] = upgrade.costs[i] * taps\r\n        }\r\n\r\n        // Juice costs\r\n        if (juiceTaps > 0) {\r\n            const juiceCost = upgrade.one_juice_cost * juiceTaps\r\n            if (upgrade.is_weapon) {\r\n                costs[8] = juiceCost // Weapons add to 9th slot (index 8)\r\n            } else {\r\n                costs[7] = juiceCost // Armors add to 8th slot (index 7)\r\n            }\r\n        }\r\n\r\n        // Free tap costs\r\n        costs[9] = upgrade.special_cost * freeTaps\r\n\r\n        return costs\r\n    }, [upgrade.taps_so_far, upgrade.juice_taps_so_far, upgrade.free_taps_so_far, upgrade.costs, upgrade.one_juice_cost, upgrade.special_cost, upgrade.is_weapon])\r\n\r\n    const handleMouseEnter = (e: React.MouseEvent) => {\r\n        tooltipHandlers.showUpgradeTooltip(upgrade, costLabels, tapRecordCosts, e.clientX, e.clientY)\r\n    }\r\n\r\n    const handleMouseMove = (e: React.MouseEvent) => {\r\n        tooltipHandlers.updateTooltipPosition(e.clientX, e.clientY)\r\n    }\r\n\r\n    const handleMouseLeave = () => {\r\n        tooltipHandlers.hideTooltip()\r\n    }\r\n\r\n    return (\r\n        <div\r\n            onMouseEnter={handleMouseEnter}\r\n            onMouseMove={handleMouseMove}\r\n            onMouseLeave={handleMouseLeave}\r\n        >\r\n            {children}\r\n        </div>\r\n    )\r\n})\r\n\r\nexport default function GambaSelection({\r\n    upgradeArr,\r\n    sortedWithIndex,\r\n    selectedUpgradeIndex,\r\n    handleUpgradeSelection,\r\n    isAutoAttempting,\r\n    isAutoAttemptingThisOne,\r\n    tooltipHandlers\r\n}: GambaSelectionProps) {\r\n    return (\r\n        <div style={{ width: 170 }}>\r\n            <style>\r\n                {`\r\n                    .upgrade-scroll-container::-webkit-scrollbar {\r\n                        width: 6px;\r\n                    }\r\n                    .upgrade-scroll-container::-webkit-scrollbar-track {\r\n                        background: var(--background-secondary);\r\n                        border-radius: 3px;\r\n                    }\r\n                    .upgrade-scroll-container::-webkit-scrollbar-thumb {\r\n                        background: var(--border-accent);\r\n                        border-radius: 3px;\r\n                    }\r\n                    .upgrade-scroll-container::-webkit-scrollbar-thumb:hover {\r\n                        background: var(--accent-color);\r\n                    }\r\n                `}\r\n            </style>\r\n            <h4 style={{ margin: 0, fontSize: 'var(--font-size-sm)', marginBottom: 10 }}>\r\n                Upgrades: {(isAutoAttempting || isAutoAttemptingThisOne) && <span style={{ color: 'var(--error-color)', fontSize: 'var(--font-size-xs)' }}>AUTO ON</span>}\r\n            </h4>\r\n            <div\r\n                className=\"upgrade-scroll-container\"\r\n                style={{\r\n                    display: \"flex\",\r\n                    flexDirection: \"column\",\r\n                    gap: 2,\r\n                    width: 170,\r\n                    maxHeight: \"800px\", // Cap at approximately 10 items (8px padding + 2px gap per item)\r\n                    overflowY: \"auto\",\r\n                    paddingRight: \"4px\" // Add some padding for the scrollbar\r\n                }}>\r\n                {sortedWithIndex.map(originalIndex => {\r\n                    const upgrade = upgradeArr[originalIndex]\r\n                    return (\r\n                        <UpgradeTooltip key={originalIndex} upgrade={upgrade} tooltipHandlers={tooltipHandlers}>\r\n                            <div\r\n                                onClick={() => handleUpgradeSelection(originalIndex)}\r\n                                style={{\r\n                                    padding: '8px',\r\n                                    border: selectedUpgradeIndex === originalIndex ? '2px solid var(--selected-blue)' : '1px solid var(--border-accent)',\r\n                                    borderRadius: '4px',\r\n                                    cursor: 'pointer',\r\n                                    backgroundColor: 'transparent',\r\n                                    fontSize: 'var(--font-size-sm)',\r\n                                    position: 'relative',\r\n                                    animation: (isAutoAttempting || isAutoAttemptingThisOne) && selectedUpgradeIndex === originalIndex ? 'pulse 1s infinite' : 'none',\r\n                                    color: upgrade.is_finished ? 'var(--btn-success)' : 'var(--text-primary)'\r\n                                }}\r\n                            >\r\n                                {upgrade.is_normal_honing ? '+' : 'Adv +'}{upgrade.is_normal_honing ? upgrade.upgrade_plus_num + 1 : (upgrade.upgrade_plus_num + 1) * 10} {upgrade.equipment_type}\r\n                                {upgrade.is_normal_honing && (\r\n                                    <span style={{ marginLeft: '4px', fontSize: 'var(--font-size-xs)' }}>\r\n                                        {((upgrade.current_artisan ?? 0) * 100).toFixed(0)}% Artisan\r\n                                    </span>\r\n                                )}\r\n\r\n                            </div>\r\n                        </UpgradeTooltip>\r\n                    )\r\n                })}\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n","import { useCallback, useRef } from \"react\"\r\nimport { Upgrade, getNextUnfinishedIndex, calculateCurrentChance, updateCumulativeChance } from \"./utils.ts\"\r\n\r\ninterface GambaLogicProps {\r\n    upgradeArr: Upgrade[]\r\n    setUpgradeArr: React.Dispatch<React.SetStateAction<Upgrade[]>>\r\n    selectedUpgradeIndex: number | null\r\n    setSelectedUpgradeIndex: React.Dispatch<React.SetStateAction<number | null>>\r\n    finalCosts: number[]\r\n    setFinalCosts: React.Dispatch<React.SetStateAction<number[]>>\r\n    completionCounter: number\r\n    setCompletionCounter: React.Dispatch<React.SetStateAction<number>>\r\n    isAutoAttempting: boolean\r\n    setIsAutoAttempting: React.Dispatch<React.SetStateAction<boolean>>\r\n    isAutoAttemptingThisOne: boolean\r\n    setIsAutoAttemptingThisOne: React.Dispatch<React.SetStateAction<boolean>>\r\n    unfinishedNormalUpgrades: Upgrade[]\r\n    flushUpgradeArrToState: (_immediate?: boolean) => void\r\n}\r\n\r\nexport function useGambaLogic({\r\n    upgradeArr,\r\n    setUpgradeArr,\r\n    selectedUpgradeIndex,\r\n    setSelectedUpgradeIndex,\r\n    finalCosts,\r\n    setFinalCosts,\r\n    completionCounter,\r\n    setCompletionCounter,\r\n    isAutoAttempting,\r\n    setIsAutoAttempting,\r\n    isAutoAttemptingThisOne,\r\n    setIsAutoAttemptingThisOne,\r\n    unfinishedNormalUpgrades,\r\n    flushUpgradeArrToState\r\n}: GambaLogicProps) {\r\n    // Refs for stable references\r\n    const upgradeArrRef = useRef(upgradeArr)\r\n    const selectedUpgradeIndexRef = useRef(selectedUpgradeIndex)\r\n    const finalCostsRef = useRef(finalCosts)\r\n    const isAutoAttemptingRef = useRef(isAutoAttempting)\r\n    const isAutoAttemptingThisOneRef = useRef(isAutoAttemptingThisOne)\r\n    const intervalRef = useRef<number | null>(null)\r\n\r\n    // Update refs when state changes\r\n    upgradeArrRef.current = upgradeArr\r\n    selectedUpgradeIndexRef.current = selectedUpgradeIndex\r\n    finalCostsRef.current = finalCosts\r\n    isAutoAttemptingRef.current = isAutoAttempting\r\n    isAutoAttemptingThisOneRef.current = isAutoAttemptingThisOne\r\n\r\n    const performAttempt = useCallback(() => {\r\n        const selIdx = selectedUpgradeIndexRef.current\r\n\r\n        const arr = upgradeArrRef.current\r\n        // console.log(selIdx, arr[selIdx].taps_so_far)\r\n        if (selIdx === null || !arr || !arr[selIdx]) {\r\n            // nothing to attempt — stop auto attempting if running\r\n            if (intervalRef.current != null) {\r\n                clearTimeout(intervalRef.current)\r\n                intervalRef.current = null\r\n                setIsAutoAttempting(false)\r\n                isAutoAttemptingRef.current = false\r\n                setIsAutoAttemptingThisOne(false)\r\n                isAutoAttemptingThisOneRef.current = false\r\n            }\r\n            return\r\n        }\r\n\r\n        const upgrade = arr[selIdx]\r\n\r\n        // Skip if upgrade is already finished\r\n        if (upgrade.is_finished) {\r\n            return\r\n        }\r\n\r\n        // Helper function to perform a single attempt\r\n        const performSingleAttempt = () => {\r\n            let success = false\r\n            let advTapCount = -1;\r\n\r\n            if (upgrade.is_normal_honing) {\r\n                const currentChance = calculateCurrentChance(upgrade)\r\n                success = Math.random() < currentChance\r\n            } else {\r\n                // Advanced honing logic - simulate tap count based on probability distribution\r\n                // Use other strategy's probability distribution if juice is ticked\r\n                let probDistToUse = upgrade.prob_dist\r\n                if (upgrade.use_juice && upgrade.other_prob_dist) {\r\n                    probDistToUse = upgrade.other_prob_dist\r\n                }\r\n\r\n                // Sample from the probability distribution\r\n                const random = Math.random()\r\n                let cumulativeProb = 0\r\n                let tapIndex = 0\r\n                for (let i = 0; i < probDistToUse.length; i++) {\r\n                    cumulativeProb += probDistToUse[i]\r\n                    if (random <= cumulativeProb) {\r\n                        tapIndex = i\r\n                        break\r\n                    }\r\n                }\r\n                upgrade.cumulative_chance = cumulativeProb\r\n\r\n                advTapCount = upgrade.tap_offset + tapIndex\r\n                success = true\r\n                upgrade.taps_so_far = advTapCount - 1\r\n            }\r\n\r\n            // Add costs to final_costs (functional update + keep ref in sync)\r\n            setFinalCosts(prev => {\r\n                const next = prev.slice()\r\n                if (upgrade.is_normal_honing) {\r\n                    for (let i = 0; i < 7; i++) {\r\n                        next[i] = (next[i] ?? 0) + (upgrade.costs?.[i] ?? 0)\r\n                    }\r\n                    if (upgrade.use_juice) {\r\n                        const juiceCost = upgrade.one_juice_cost ?? 0\r\n                        if (upgrade.is_weapon) next[7] = (next[7] ?? 0) + juiceCost\r\n                        else next[8] = (next[8] ?? 0) + juiceCost\r\n                    }\r\n                }\r\n                else {\r\n                    for (let i = 0; i < 7; i++) {\r\n                        next[i] = (next[i] ?? 0) + (upgrade.costs?.[i] * advTapCount)\r\n                    }\r\n                    if (upgrade.use_juice) {\r\n                        const juiceCost = upgrade.adv_juice_cost[advTapCount - upgrade.tap_offset] ?? 0\r\n                        if (upgrade.is_weapon) next[7] = (next[7] ?? 0) + juiceCost\r\n                        else next[8] = (next[8] ?? 0) + juiceCost\r\n                    }\r\n                }\r\n                finalCostsRef.current = next\r\n                return next\r\n            })\r\n\r\n            // Update upgrade counters\r\n            upgrade.taps_so_far = (upgrade.taps_so_far || 0) + 1\r\n            upgrade.juice_taps_so_far = (upgrade.juice_taps_so_far || 0) + (upgrade.use_juice ? 1 : 0)\r\n\r\n            // Update cumulative chance for normal honing\r\n            if (upgrade.is_normal_honing) {\r\n                const currentChance = calculateCurrentChance(upgrade)\r\n                updateCumulativeChance(upgrade, currentChance)\r\n\r\n                // Increment artisan on failure for normal honing\r\n                if (!success) {\r\n                    upgrade.current_artisan = Math.min(1, (upgrade.current_artisan || 0) + (46.51 / 100.0) * currentChance * (upgrade.artisan_rate ?? 0))\r\n                }\r\n            }\r\n\r\n            return { success, advTapCount }\r\n        }\r\n\r\n        // Perform attempts until success when isAutoAttempting is true\r\n        let success = false\r\n\r\n        if (isAutoAttemptingRef.current && !isAutoAttemptingThisOneRef.current) {\r\n            // Loop until success for auto-attempting all\r\n            do {\r\n                const result = performSingleAttempt()\r\n                success = result.success\r\n            } while (!success)\r\n        } else {\r\n            // Single attempt for manual or \"this one\" auto-attempting\r\n            const result = performSingleAttempt()\r\n            success = result.success\r\n        }\r\n\r\n        if (success) {\r\n            upgrade.is_finished = true\r\n            upgrade.completion_order = (upgrade.completion_order || 0) + 1\r\n            setCompletionCounter(prev => prev + 1)\r\n            // Handle auto-attempting logic\r\n            if (isAutoAttemptingThisOneRef.current) {\r\n                // Stop \"this one\" auto-attempting since the upgrade succeeded\r\n                if (intervalRef.current != null) {\r\n                    clearTimeout(intervalRef.current)\r\n                    intervalRef.current = null\r\n                }\r\n                setIsAutoAttemptingThisOne(false)\r\n                isAutoAttemptingThisOneRef.current = false\r\n                setIsAutoAttempting(false)\r\n                isAutoAttemptingRef.current = false\r\n\r\n                // const nextUnfinishedIndex = upgradeArrRef.current.findIndex(\r\n                //     (z) => z == sortedUpgrades(upgradeArrRef.current).find((upg, i) =>\r\n                //         !upg.is_finished && i !== selIdx))\r\n                // // console.log(\"thisone\", nextUnfinishedIndex)\r\n                // if (nextUnfinishedIndex !== -1) {\r\n                //     setSelectedUpgradeIndex(nextUnfinishedIndex)\r\n                //     selectedUpgradeIndexRef.current = nextUnfinishedIndex\r\n                // }\r\n            } else if (isAutoAttemptingRef.current) {\r\n\r\n                // Move to next unfinished upgrade if auto-attempting all\r\n                const nextUnfinishedIndex = getNextUnfinishedIndex(upgradeArrRef.current, selIdx)\r\n                // console.log(\"auto\", nextUnfinishedIndex, upgradeArrRef.current[nextUnfinishedIndex])\r\n                if (nextUnfinishedIndex !== -1) {\r\n                    setSelectedUpgradeIndex(nextUnfinishedIndex)\r\n                    selectedUpgradeIndexRef.current = nextUnfinishedIndex\r\n                } else {\r\n                    // No more unfinished normal honing upgrades, stop auto-attempting\r\n                    if (intervalRef.current != null) {\r\n                        clearTimeout(intervalRef.current)\r\n                        intervalRef.current = null\r\n                    }\r\n                    setIsAutoAttempting(false)\r\n                    isAutoAttemptingRef.current = false\r\n\r\n                }\r\n            }\r\n            // Note: Manual taps do not automatically move to next upgrade\r\n\r\n        }\r\n\r\n        // Update the upgrade in the ref array\r\n        upgradeArrRef.current[selIdx] = upgrade\r\n\r\n        // If success (user-visible change) flush immediately, else schedule a coalesced update\r\n        if (success) {\r\n            flushUpgradeArrToState(true)\r\n        } else {\r\n            flushUpgradeArrToState(false)\r\n        }\r\n    }, [flushUpgradeArrToState, setFinalCosts, setCompletionCounter, setSelectedUpgradeIndex, setIsAutoAttempting, setIsAutoAttemptingThisOne])\r\n\r\n    // Attempt a tap\r\n    const attemptTap = useCallback(() => performAttempt(), [performAttempt])\r\n\r\n    // Toggle auto-attempt mode\r\n    const startAuto = useCallback((ms: number) => {\r\n        if (intervalRef.current != null) return\r\n        isAutoAttemptingRef.current = true\r\n        setIsAutoAttempting(true)\r\n\r\n        const tick = () => {\r\n            performAttempt()\r\n            if (isAutoAttemptingRef.current) {\r\n                intervalRef.current = window.setTimeout(tick, Math.max(5, ms)) // enforce min delay\r\n            } else {\r\n                intervalRef.current = null\r\n            }\r\n        }\r\n        tick()\r\n    }, [performAttempt, setIsAutoAttempting])\r\n\r\n    const stopAuto = useCallback(() => {\r\n        if (intervalRef.current != null) {\r\n            clearTimeout(intervalRef.current)\r\n            intervalRef.current = null\r\n        }\r\n        setIsAutoAttempting(false)\r\n        isAutoAttemptingRef.current = false\r\n        setIsAutoAttemptingThisOne(false)\r\n        isAutoAttemptingThisOneRef.current = false\r\n    }, [setIsAutoAttempting, setIsAutoAttemptingThisOne])\r\n\r\n    const toggleAutoAttempt = useCallback(() => {\r\n        if (isAutoAttemptingRef.current) {\r\n            stopAuto()\r\n        } else {\r\n            // Only start auto-attempt if there are unfinished normal honing upgrades\r\n            if (unfinishedNormalUpgrades.length > 0) {\r\n                if (!selectedUpgradeIndex ||\r\n                    !upgradeArr[selectedUpgradeIndex] ||\r\n                    upgradeArr[selectedUpgradeIndex].is_finished) {\r\n                    const nextUnfinishedIndex = getNextUnfinishedIndex(upgradeArrRef.current, selectedUpgradeIndex)\r\n                    setSelectedUpgradeIndex(nextUnfinishedIndex)\r\n                    selectedUpgradeIndexRef.current = nextUnfinishedIndex\r\n                }\r\n                startAuto(0) // 10ms per your request\r\n            }\r\n        }\r\n    }, [startAuto, stopAuto, unfinishedNormalUpgrades, selectedUpgradeIndexRef, setSelectedUpgradeIndex, upgradeArr, selectedUpgradeIndex])\r\n\r\n    const toggleAutoAttemptThisOne = useCallback(() => {\r\n        if (isAutoAttemptingThisOneRef.current) {\r\n            stopAuto()\r\n        } else {\r\n            // Only start \"this one\" auto-attempt if there's a selected upgrade and it's not finished\r\n            if (selectedUpgradeIndex !== null && upgradeArr[selectedUpgradeIndex] && !upgradeArr[selectedUpgradeIndex].is_finished) {\r\n                setIsAutoAttemptingThisOne(true)\r\n                isAutoAttemptingThisOneRef.current = true\r\n                startAuto(10) // 1ms for faster auto-attempting\r\n            }\r\n        }\r\n    }, [startAuto, stopAuto, selectedUpgradeIndex, upgradeArr, setIsAutoAttemptingThisOne])\r\n\r\n    // Free tap\r\n    const freeTap = useCallback(() => {\r\n        if (selectedUpgradeIndex === null || !upgradeArr[selectedUpgradeIndex]) return\r\n\r\n        const upgrade = upgradeArr[selectedUpgradeIndex]\r\n        const success = Math.random() < upgrade.base_chance\r\n\r\n        // Add special cost to 10th element\r\n        setFinalCosts(prev => {\r\n            const next = prev.slice()\r\n            next[9] = (next[9] || 0) + upgrade.special_cost\r\n            return next\r\n        })\r\n\r\n        if (success) {\r\n            // Success - mark as finished and update tap counts\r\n            setUpgradeArr(prev => {\r\n                const next = prev.slice()\r\n                const updatedUpgrade = {\r\n                    ...next[selectedUpgradeIndex],\r\n                    is_finished: true,\r\n                    completion_order: completionCounter + 1,\r\n                    free_taps_so_far: (next[selectedUpgradeIndex].free_taps_so_far ?? 0) + 1,\r\n                }\r\n                // Update cumulative chance for normal honing (free tap uses base chance)\r\n                if (updatedUpgrade.is_normal_honing) {\r\n                    updateCumulativeChance(updatedUpgrade, updatedUpgrade.base_chance)\r\n                }\r\n                next[selectedUpgradeIndex] = updatedUpgrade\r\n                return next\r\n            })\r\n\r\n            setCompletionCounter(prev => prev + 1)\r\n        } else {\r\n            // Failure - still track the free tap\r\n            setUpgradeArr(prev => {\r\n                const next = prev.slice()\r\n                const updatedUpgrade = {\r\n                    ...next[selectedUpgradeIndex],\r\n                    free_taps_so_far: (next[selectedUpgradeIndex].free_taps_so_far ?? 0) + 1\r\n                }\r\n                // Update cumulative chance for normal honing (free tap uses base chance)\r\n                if (updatedUpgrade.is_normal_honing) {\r\n                    updateCumulativeChance(updatedUpgrade, updatedUpgrade.base_chance)\r\n                }\r\n                next[selectedUpgradeIndex] = updatedUpgrade\r\n                return next\r\n            })\r\n        }\r\n    }, [selectedUpgradeIndex, upgradeArr, setFinalCosts, setUpgradeArr, completionCounter, setCompletionCounter])\r\n\r\n    return {\r\n        attemptTap,\r\n        toggleAutoAttempt,\r\n        toggleAutoAttemptThisOne,\r\n        freeTap\r\n    }\r\n}\r\n","import React, { useState, useEffect, useRef, useMemo, useCallback } from \"react\"\nimport SpreadsheetGrid from \"../../components/SpreadsheetGrid.tsx\"\nimport Graph from \"../../components/Graph.tsx\"\nimport { styles, createColumnDefs, GRAPH_WIDTH, GRAPH_HEIGHT, SMALL_GRAPH_WIDTH, SMALL_GRAPH_HEIGHT } from \"./styles.ts\"\nimport { BOTTOM_COLS, INPUT_LABELS, TOP_COLS, OUTPUT_LABELS } from \"./constants.ts\"\nimport { SpawnWorker } from \"../../worker_setup.ts\"\nimport { buildPayload } from \"./Debounce.ts\"\nimport { Upgrade, EQUIPMENT_TYPES } from \"./utils.ts\"\nimport GambaInfoBox from \"./GambaInfoBox.tsx\"\nimport GambaSelection from \"./GambaSelection.tsx\"\nimport { useGambaLogic } from \"./GambaLogic.tsx\"\n\n\ntype GambaSectionProps = {\n    budget_inputs: any\n    set_budget_inputs: React.Dispatch<React.SetStateAction<any>>\n    userMatsValue: any\n    setUserMatsValue: React.Dispatch<React.SetStateAction<any>>\n    topGrid: boolean[][]\n    bottomGrid: boolean[][]\n    adv_hone_strategy: string\n    express_event: boolean\n    desired_chance: string\n    bucketCount: string\n    autoOptimization: boolean\n    dataSize: string\n    tooltipHandlers: {\n        showUpgradeTooltip: (_upgrade: any, _costLabels: string[], _tapRecordCosts: number[], _x: number, _y: number) => void\n        hideTooltip: () => void\n        updateTooltipPosition: (_x: number, _y: number) => void\n    }\n    chance_result: any\n    cachedChanceGraphData: { hist_counts?: any, hist_mins?: any, hist_maxs?: any } | null\n    AnythingTicked: boolean\n    CostToChanceBusy: boolean\n    cumulativeGraph: boolean\n    lockXAxis: boolean\n    lockedMins: number[] | null\n    lockedMaxs: number[] | null\n    useGridInput: boolean\n    normalCounts: number[][]\n    advCounts: number[][]\n    upgradeArr: any[]\n    ParserBusy: boolean\n}\n\n\nexport default function GambaSection({\n    budget_inputs,\n    set_budget_inputs,\n    userMatsValue,\n    setUserMatsValue,\n    topGrid,\n    bottomGrid,\n    adv_hone_strategy,\n    express_event,\n\n    bucketCount,\n    autoOptimization,\n    dataSize,\n    tooltipHandlers,\n    chance_result,\n    cachedChanceGraphData,\n    AnythingTicked,\n    CostToChanceBusy,\n    cumulativeGraph,\n    lockXAxis,\n    lockedMins,\n    lockedMaxs,\n    useGridInput,\n    normalCounts,\n    advCounts,\n}: GambaSectionProps) {\n    const { costToChanceColumnDefs } = createColumnDefs(true)\n\n    // State management\n    const [upgradeArr, setUpgradeArr] = useState<Upgrade[]>([])\n    const [selectedUpgradeIndex, setSelectedUpgradeIndex] = useState<number | null>(0)\n    const [finalCosts, setFinalCosts] = useState<number[]>(new Array(10).fill(0))\n    const [unlockCosts, setUnlockCosts] = useState<number[]>(new Array(2).fill(0))\n    const [isAutoAttempting, setIsAutoAttempting] = useState<boolean>(false)\n    const [isAutoAttemptingThisOne, setIsAutoAttemptingThisOne] = useState<boolean>(false)\n    const [completionCounter, setCompletionCounter] = useState<number>(0)\n    const [refreshKey, setRefreshKey] = useState<boolean>(false)\n\n    // Worker refs and debounce\n    const parserWorkerRef = useRef<Worker | null>(null)\n    const debounceTimerRef = useRef<number | null>(null)\n    const pendingRequests = useRef(new Map<string, (_data: any) => void>())\n    const autoAttemptIntervalRef = useRef<number | null>(null)\n    const currentUpgradeArrRef = useRef<Upgrade[]>([])\n    const currentSelectedIndexRef = useRef<number | null>(null)\n    const selectedUpgradeIndexRef = useRef(selectedUpgradeIndex)\n    const upgradeArrRef = useRef(upgradeArr)\n    const finalCostsRef = useRef(finalCosts)\n    const unlockCostsRef = useRef(unlockCosts)\n\n\n\n    const flushTimeoutRef = useRef<number | null>(null)\n\n    const flushUpgradeArrToState = useCallback((immediate = false) => {\n        if (immediate) {\n            if (flushTimeoutRef.current) {\n                clearTimeout(flushTimeoutRef.current)\n                flushTimeoutRef.current = null\n            }\n            // shallow copy the array to trigger React update\n            setUpgradeArr(_prev => upgradeArrRef.current.slice())\n            return\n        }\n        if (flushTimeoutRef.current != null) return\n        flushTimeoutRef.current = window.setTimeout(() => {\n            setUpgradeArr(_prev => upgradeArrRef.current.slice())\n            flushTimeoutRef.current = null\n        }, 100) // coalesce UI updates every 100ms\n    }, [])\n\n    // sync refs whenever state changes\n    useEffect(() => { selectedUpgradeIndexRef.current = selectedUpgradeIndex }, [selectedUpgradeIndex])\n    useEffect(() => { upgradeArrRef.current = upgradeArr }, [upgradeArr])\n    useEffect(() => { finalCostsRef.current = finalCosts }, [finalCosts])\n    useEffect(() => { unlockCostsRef.current = unlockCosts }, [unlockCosts])\n    // Initialize parser worker\n    useEffect(() => {\n        // Create a persistent worker for parser calls\n        parserWorkerRef.current = new Worker(new URL(\"../../js_to_wasm.ts\", import.meta.url), { type: \"module\" })\n\n        // Set up message handler once\n        parserWorkerRef.current.onmessage = (e) => {\n            const { id, type, result } = e.data\n            if (type === 'result' && pendingRequests.current.has(id)) {\n                pendingRequests.current.get(id)!(result)\n                pendingRequests.current.delete(id)\n            }\n        }\n\n        return () => {\n            if (parserWorkerRef.current) {\n                parserWorkerRef.current.terminate()\n            }\n            // Clean up auto-attempt interval\n            if (autoAttemptIntervalRef.current) {\n                clearTimeout(autoAttemptIntervalRef.current)\n            }\n        }\n    }, [])\n\n    // Function to call parser and get upgrade array using unified payload format\n    const callParser = useCallback(async () => {\n        if (!parserWorkerRef.current) return\n\n        // Create payload using the same format as other functions\n        const payload = buildPayload({\n            topGrid,\n            bottomGrid,\n            budget_inputs,\n            adv_hone_strategy,\n            express_event,\n            bucketCount,\n            autoOptimization,\n            userMatsValue,\n            dataSize,\n            useGridInput,\n            normalCounts,\n            advCounts,\n        })\n\n        const id = Math.random().toString(36).substr(2, 9)\n\n        // Create promise for this request\n        const p = new Promise(_resolve => pendingRequests.current.set(id, _resolve))\n\n        parserWorkerRef.current.postMessage({\n            id,\n            payload,\n            which_one: \"ParserUnified\"\n        })\n\n        p.then((result: any) => {\n            const upgrades = result.upgrades as Upgrade[]\n            const unlocks = result.unlocks as number[]\n            const other_strategy_prob_dists = result.other_strategy_prob_dists as number[][]\n            setUnlockCosts(unlocks)\n            unlockCostsRef.current = unlocks\n\n            // Add equipment types to upgrades based on ticked equipment in grids\n            let seen_ind_normal = Array.from({ length: TOP_COLS }, () => 0);\n            let seen_ind_adv = Array.from({ length: BOTTOM_COLS }, () => 0);\n            let upgradesWithTypes = upgrades.map(upgrade => {\n                if (upgrade.is_weapon) {\n                    return { ...upgrade, equipment_type: 'Weapon' }\n                } else {\n                    // For armor, find which equipment types are ticked in the grid\n                    const equipmentTypes = EQUIPMENT_TYPES.slice(0, 5) // Exclude Weapon\n                    const assignedType = equipmentTypes.find((_, index) => {\n                        if (upgrade.is_normal_honing) {\n                            if (index < seen_ind_normal[upgrade.upgrade_plus_num]) { return false }\n                            if (useGridInput) {\n                                const gridRow = topGrid[index] || []\n                                seen_ind_normal[upgrade.upgrade_plus_num] += 1;\n                                return gridRow[upgrade.upgrade_plus_num] || false\n                            } else {\n                                // Use numeric input data - check if this equipment type has a count > 0\n                                const armorCount = normalCounts[0][upgrade.upgrade_plus_num] || 0\n                                seen_ind_normal[upgrade.upgrade_plus_num] += 1;\n                                return index < armorCount\n                            }\n                        }\n                        else {\n                            if (index < seen_ind_adv[upgrade.upgrade_plus_num]) { return false }\n                            if (useGridInput) {\n                                const gridRow = bottomGrid[index] || []\n                                seen_ind_adv[upgrade.upgrade_plus_num] += 1;\n                                return gridRow[upgrade.upgrade_plus_num] || false\n                            } else {\n                                // Use numeric input data - check if this equipment type has a count > 0\n                                const armorCount = advCounts[0][upgrade.upgrade_plus_num] || 0\n                                seen_ind_adv[upgrade.upgrade_plus_num] += 1;\n                                return index < armorCount\n                            }\n                        }\n                    })\n                    return { ...upgrade, equipment_type: assignedType || 'Armor', }\n                }\n            })\n            upgradesWithTypes.sort((a, b) => { if (a.is_normal_honing) { return -999 } else { return a.upgrade_plus_num - b.upgrade_plus_num } })\n\n            // Assign other_prob_dist to advanced honing upgrades\n            let advUpgradeIndex = 0\n            upgradesWithTypes.forEach(upgrade => {\n                if (!upgrade.is_normal_honing && advUpgradeIndex < other_strategy_prob_dists.length) {\n                    upgrade.other_prob_dist = other_strategy_prob_dists[advUpgradeIndex]\n                    advUpgradeIndex++\n                }\n            })\n\n            // Initialize upgrade completion tracking\n            setUpgradeArr(upgradesWithTypes.map(upgrade => ({\n                ...upgrade,\n                is_finished: false,\n                completion_order: 0,\n                current_artisan: 0,\n                taps_so_far: 0,\n                juice_taps_so_far: 0,\n                free_taps_so_far: 0,\n                use_juice: adv_hone_strategy === \"Juice on grace\" && !upgrade.is_normal_honing,\n                cumulative_chance: 0\n            })))\n            // Update refs\n            currentUpgradeArrRef.current = upgradesWithTypes\n        })\n    }, [topGrid, bottomGrid, adv_hone_strategy, express_event, bucketCount, autoOptimization, userMatsValue, dataSize, budget_inputs, useGridInput, normalCounts, advCounts])\n\n    // Debounce effect for parser calls when grids change\n    const advStrategyKey = useMemo(() => String(adv_hone_strategy), [adv_hone_strategy])\n    const expressEventKey = useMemo(() => String(express_event), [express_event])\n    const useGridInputKey = useMemo(() => String(useGridInput), [useGridInput])\n    const normalCountsKey = useMemo(() => JSON.stringify(normalCounts), [normalCounts])\n    const advCountsKey = useMemo(() => JSON.stringify(advCounts), [advCounts])\n    const refreshKeyMemo = useMemo(() => refreshKey, [refreshKey])\n\n    useEffect(() => {\n        // Clear existing timer\n        if (debounceTimerRef.current) {\n            window.clearTimeout(debounceTimerRef.current)\n            debounceTimerRef.current = null\n        }\n\n        // Clear final costs when grids or strategy change\n        setFinalCosts(new Array(10).fill(0))\n        setSelectedUpgradeIndex(null)\n\n        // Stop auto-attempting when grids change\n        if (autoAttemptIntervalRef.current) {\n            clearTimeout(autoAttemptIntervalRef.current)\n            autoAttemptIntervalRef.current = null\n        }\n        setIsAutoAttempting(false)\n\n        // Start new delayed work\n        debounceTimerRef.current = window.setTimeout(() => {\n            callParser()\n            debounceTimerRef.current = null\n        }, 100) // 100ms debounce\n\n        return () => {\n            if (debounceTimerRef.current) {\n                window.clearTimeout(debounceTimerRef.current)\n                debounceTimerRef.current = null\n            }\n        }\n    }, [advStrategyKey, expressEventKey, refreshKeyMemo, callParser, useGridInputKey, normalCountsKey, advCountsKey])\n\n    // Keep refs updated\n    useEffect(() => {\n        currentUpgradeArrRef.current = upgradeArr\n    }, [upgradeArr])\n\n    useEffect(() => {\n        currentSelectedIndexRef.current = selectedUpgradeIndex\n    }, [selectedUpgradeIndex])\n\n\n\n\n    // Memoize sorted indices to avoid O(n²) findIndex operations in render\n    const sortedWithIndex = useMemo(() => {\n        // create array of indices and sort indices only (no object copies)\n        const idxs = upgradeArr.map((_, i) => i)\n        idxs.sort((ia, ib) => {\n            const a = upgradeArr[ia], b = upgradeArr[ib]\n            // same comparison code as sortedUpgrades but using a & b\n            if (a.is_finished < b.is_finished) return -1\n            if (a.is_finished > b.is_finished) return 1\n            if (a.is_normal_honing < b.is_normal_honing) return 1\n            if (a.is_normal_honing > b.is_normal_honing) return -1\n            if (a.is_finished && b.is_finished) {\n                return (a.completion_order || 0) - (b.completion_order || 0)\n            }\n            if (!a.is_finished && !b.is_finished) {\n                if (a.upgrade_plus_num < b.upgrade_plus_num) return -1\n                if (a.upgrade_plus_num > b.upgrade_plus_num) return 1\n                return EQUIPMENT_TYPES.findIndex(v => a.equipment_type == v)\n                    - EQUIPMENT_TYPES.findIndex(v => b.equipment_type == v)\n            }\n            return 0\n        })\n        return idxs // array of original indices in sorted order\n    }, [upgradeArr])\n\n    // Get unfinished normal honing upgrades for auto-attempt logic\n    const unfinishedNormalUpgrades = useMemo(() => {\n        return upgradeArr.filter(upgrade => !upgrade.is_finished)\n    }, [upgradeArr])\n\n    // Use the GambaLogic hook for tapping functionality\n    const { attemptTap, toggleAutoAttempt, toggleAutoAttemptThisOne, freeTap } = useGambaLogic({\n        upgradeArr,\n        setUpgradeArr,\n        selectedUpgradeIndex,\n        setSelectedUpgradeIndex,\n        finalCosts,\n        setFinalCosts,\n        completionCounter,\n        setCompletionCounter,\n        isAutoAttempting,\n        setIsAutoAttempting,\n        isAutoAttemptingThisOne,\n        setIsAutoAttemptingThisOne,\n        unfinishedNormalUpgrades,\n        flushUpgradeArrToState\n    })\n\n    // Handle upgrade selection\n    const handleUpgradeSelection = useCallback((index: number) => {\n        setSelectedUpgradeIndex(index)\n    }, [])\n\n    const handleRefresh = useCallback(() => {\n        setRefreshKey(prev => !prev)\n    }, [])\n\n\n    // Calculate budget remaining\n    const budgetRemaining = INPUT_LABELS.map((label, index) => {\n        const budget = parseInt(budget_inputs[label] || '0')\n        const finalCost = finalCosts[index] || 0\n        return budget - finalCost\n    })\n\n    // Create budget data for SpreadsheetGrid\n    const budgetTotalData = INPUT_LABELS.reduce((acc, label, index) => {\n        acc[label] = (finalCosts[index] + (index === 3 ? unlockCosts[0] : index === 6 ? unlockCosts[1] : 0)).toFixed(0).toString()\n        return acc\n    }, {} as Record<string, string>)\n\n    const budgetRemainingData = INPUT_LABELS.reduce((acc, label, index) => {\n        acc[label] = budgetRemaining[index].toFixed(0).toString()\n        return acc\n    }, {} as Record<string, string>)\n\n    // Column definitions for budget grid (2 columns: Total Cost, Remaining)\n    const budgetColumnDefs = [\n        {\n            headerName: \"Total Cost\",\n            field: \"total\",\n            editable: false,\n            flex: 1,\n            cellStyle: {\n                backgroundColor: 'var(--background-secondary)',\n                color: 'var(--text-primary)'\n            }\n        },\n        {\n            headerName: \"Remaining\",\n            field: \"remaining\",\n            editable: false,\n            flex: 1,\n            cellStyle: (params: any) => {\n                const value = parseInt(params.value || '0')\n                return {\n                    backgroundColor: value < 0 ? 'var(--ran-out)' : 'transparent',\n                    color: value < 0 ? 'white' : 'var(--text-primary)'\n                }\n            }\n        }\n    ]\n\n    return (\n        <>\n            <style>\n                {`\n                    @keyframes pulse {\n                        0% { opacity: 1; }\n                        50% { opacity: 0.7; }\n                        100% { opacity: 1; }\n                    }\n                `}\n            </style>\n            {/* <h3 style={{ color: 'var(--text-primary)', fontSize: 'var(--font-size-base)', fontWeight: 'var(--font-weight-semibold)', margin: '16px 0 0px 0' }}>Gamba Section</h3> */}\n\n            <div style={{ ...styles.inputSection, flexDirection: \"row\", maxWidth: \"1200px\", width: \"100%\" }}>\n                <div style={{ display: \"flex\", gap: 20, alignItems: \"flex-start\" }}>\n                    {/* Budget Input Grid */}\n                    <div style={{ display: 'flex', flexDirection: \"column\", gap: 0, alignItems: 'flex-start', justifyContent: 'start', width: autoOptimization ? 210 : 300 }}>\n                        <div style={{ width: 210 }}>\n                            <SpreadsheetGrid\n                                columnDefs={costToChanceColumnDefs}\n                                labels={INPUT_LABELS}\n                                sheet_values={budget_inputs}\n                                set_sheet_values={set_budget_inputs}\n                                secondaryValues={userMatsValue}\n                                setSecondaryValues={setUserMatsValue}\n                            />\n                        </div>\n                        <div style={{ display: 'flex', alignItems: 'center', gap: 12, marginBottom: 8 }}>\n                            <div style={{ ...styles.inputLabelCell, whiteSpace: 'nowrap', backgroundColor: 'var(--bg-tertiary)' }}>Chance of Success</div>\n                            <div style={{ ...styles.inputCell, border: 'none', background: \"transparent\", color: 'var(--text-success)', fontSize: 'var(--font-size-xl)' }}>{chance_result ? (String(chance_result.chance) + '%') : '-'}</div>\n                        </div>\n                        <button\n                            onClick={handleRefresh}\n                            style={{\n                                padding: '8px 16px',\n                                backgroundColor: 'var(--btn-primary)',\n                                color: 'var(--text-primary)',\n                                border: '1px solid var(--border-accent)',\n                                borderRadius: '4px',\n                                cursor: 'pointer',\n                                fontSize: 'var(--font-size-sm)',\n                                fontWeight: 'var(--font-weight-bold)'\n                            }}\n                        >\n                            Restart gamba\n                        </button>\n                    </div>\n\n                    {/* Upgrade Selection Grid */}\n                    <GambaSelection\n                        upgradeArr={upgradeArr}\n                        sortedWithIndex={sortedWithIndex}\n                        selectedUpgradeIndex={selectedUpgradeIndex}\n                        handleUpgradeSelection={handleUpgradeSelection}\n                        isAutoAttempting={isAutoAttempting}\n                        isAutoAttemptingThisOne={isAutoAttemptingThisOne}\n                        tooltipHandlers={tooltipHandlers}\n                    />\n\n                    {/* Upgrade Info Box and Budget Remaining */}\n                    <div style={{ display: \"flex\", flexDirection: \"column\", gap: 0 }}>\n                        <div style={{ display: \"flex\", gap: 20 }}>\n                            {/* Upgrade Info Box - Always shown */}\n                            <GambaInfoBox\n                                upgradeArr={upgradeArr}\n                                selectedUpgradeIndex={selectedUpgradeIndex}\n                                setUpgradeArr={setUpgradeArr}\n                                attemptTap={attemptTap}\n                                toggleAutoAttemptThisOne={toggleAutoAttemptThisOne}\n                                toggleAutoAttempt={toggleAutoAttempt}\n                                freeTap={freeTap}\n                                isAutoAttempting={isAutoAttempting}\n                                isAutoAttemptingThisOne={isAutoAttemptingThisOne}\n                                unfinishedNormalUpgrades={unfinishedNormalUpgrades}\n                                adv_hone_strategy={adv_hone_strategy}\n                            />\n\n                            {/* Budget Grid (Total Cost + Remaining) */}\n                            <div style={{ width: 200, marginLeft: 70 }}>\n                                <SpreadsheetGrid\n                                    columnDefs={budgetColumnDefs}\n                                    labels={INPUT_LABELS}\n                                    sheet_values={budgetTotalData}\n                                    set_sheet_values={() => { }} // Read-only\n                                    secondaryValues={budgetRemainingData}\n                                    setSecondaryValues={() => { }} // Read-only\n                                    readOnly={true}\n                                />\n                            </div>\n                        </div>\n                        {/* Graph Section */}\n                        <div style={{ marginTop: 20, display: 'flex', gap: 20 }}>\n                            <div style={{ flex: 1 }}>\n                                <Graph\n                                    title=\"Budget vs Total Cost Distribution\"\n                                    labels={OUTPUT_LABELS}\n                                    counts={AnythingTicked ? (chance_result?.hist_counts || cachedChanceGraphData?.hist_counts) : null}\n                                    mins={chance_result?.hist_mins || cachedChanceGraphData?.hist_mins}\n                                    maxs={chance_result?.hist_maxs || cachedChanceGraphData?.hist_maxs}\n                                    width={SMALL_GRAPH_WIDTH}\n                                    height={SMALL_GRAPH_HEIGHT}\n                                    budgets={OUTPUT_LABELS.map(label => Number(budget_inputs[label] || 0))}\n                                    additionalBudgets={finalCosts.slice(0, 7).map((v, i) => v + (i === 3 ? unlockCosts[0] : i === 6 ? unlockCosts[1] : 0))} // First 7 elements for total costs\n                                    hasSelection={AnythingTicked}\n                                    isLoading={CostToChanceBusy}\n                                    cumulative={cumulativeGraph}\n                                    lockXAxis={lockXAxis}\n                                    lockedMins={lockedMins}\n                                    lockedMaxs={lockedMaxs}\n                                />\n                            </div>\n                        </div>\n                    </div>\n                </div>\n            </div >\n\n\n\n        </>\n    )\n}"],"names":["GambaInfoBox","upgradeArr","selectedUpgradeIndex","setUpgradeArr","attemptTap","toggleAutoAttemptThisOne","toggleAutoAttempt","freeTap","isAutoAttempting","isAutoAttemptingThisOne","unfinishedNormalUpgrades","adv_hone_strategy","selectedUpgrade","isFinished","jsxs","Fragment","calculateCurrentChance","rangeInfo","getTapCountRange","jsx","_a","e","prev","next","_b","_c","_d","_e","_f","_g","_h","_i","_j","_k","_l","_m","UpgradeTooltip","React","upgrade","children","tooltipHandlers","costLabels","tapRecordCosts","costs","taps","juiceTaps","freeTaps","i","juiceCost","handleMouseEnter","handleMouseMove","handleMouseLeave","GambaSelection","sortedWithIndex","handleUpgradeSelection","originalIndex","useGambaLogic","setSelectedUpgradeIndex","finalCosts","setFinalCosts","completionCounter","setCompletionCounter","setIsAutoAttempting","setIsAutoAttemptingThisOne","flushUpgradeArrToState","upgradeArrRef","useRef","selectedUpgradeIndexRef","finalCostsRef","isAutoAttemptingRef","isAutoAttemptingThisOneRef","intervalRef","performAttempt","useCallback","selIdx","arr","performSingleAttempt","success","advTapCount","currentChance","probDistToUse","random","cumulativeProb","tapIndex","updateCumulativeChance","nextUnfinishedIndex","getNextUnfinishedIndex","startAuto","ms","tick","stopAuto","updatedUpgrade","GambaSection","budget_inputs","set_budget_inputs","userMatsValue","setUserMatsValue","topGrid","bottomGrid","express_event","bucketCount","autoOptimization","dataSize","chance_result","cachedChanceGraphData","AnythingTicked","CostToChanceBusy","cumulativeGraph","lockXAxis","lockedMins","lockedMaxs","useGridInput","normalCounts","advCounts","costToChanceColumnDefs","createColumnDefs","useState","unlockCosts","setUnlockCosts","refreshKey","setRefreshKey","parserWorkerRef","debounceTimerRef","pendingRequests","autoAttemptIntervalRef","currentUpgradeArrRef","currentSelectedIndexRef","unlockCostsRef","flushTimeoutRef","immediate","_prev","useEffect","id","type","result","callParser","payload","buildPayload","p","_resolve","upgrades","unlocks","other_strategy_prob_dists","seen_ind_normal","TOP_COLS","seen_ind_adv","BOTTOM_COLS","upgradesWithTypes","assignedType","EQUIPMENT_TYPES","_","index","gridRow","armorCount","a","b","advUpgradeIndex","advStrategyKey","useMemo","expressEventKey","useGridInputKey","normalCountsKey","advCountsKey","refreshKeyMemo","idxs","ia","ib","v","handleRefresh","budgetRemaining","INPUT_LABELS","label","budget","finalCost","budgetTotalData","acc","budgetRemainingData","budgetColumnDefs","params","value","styles","SpreadsheetGrid","Graph","OUTPUT_LABELS","SMALL_GRAPH_WIDTH","SMALL_GRAPH_HEIGHT"],"mappings":"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"}