{"version":3,"file":"utils-BdNnqXCI.js","sources":["../../src/Frontend/features/honing_forecast/Settings.ts","../../src/Frontend/features/honing_forecast/HistogramUtils.ts","../../src/Frontend/features/honing_forecast/utils.ts","../../src/Frontend/features/honing_forecast/Debounce.ts","../../src/Frontend/features/honing_forecast/Separator.tsx","../../src/Frontend/features/honing_forecast/Tooltip.tsx","../../src/Frontend/features/honing_forecast/Marquee.ts"],"sourcesContent":["import { INPUT_LABELS, OUTPUT_LABELS, STORAGE_KEY, TOP_ROWS, TOP_COLS, BOTTOM_ROWS, BOTTOM_COLS, CELL_W, CELL_H } from \"./constants.ts\"\n\nexport function writeSettings(\n    topGrid,\n    bottomGrid,\n    adv_hone_strategy,\n    express_event,\n    prev_checked_arr,\n    prev_checked_arr_bottom,\n    desired_chance,\n    budget_inputs,\n    autoOptimization,\n    userMatsValue,\n    cumulativeGraph,\n    dataSize,\n    useGridInput,\n    normalCounts,\n    advCounts\n) {\n    const toSave = {\n        topGrid,\n        bottomGrid,\n        adv_hone_strategy,\n        express_event,\n        prev_checked_arr,\n        prev_checked_arr_bottom,\n        desired_chance,\n        budget_inputs,\n        autoOptimization,\n        userMatsValue,\n        cumulativeGraph,\n        dataSize,\n        useGridInput,\n        normalCounts,\n        advCounts,\n    }\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(toSave))\n}\nexport function readSettings(\n    setTopGrid,\n    setBottomGrid,\n    set_adv_hone_strategy_change,\n    set_express_event,\n    set_prev_checked_arr,\n    set_prev_checked_arr_bottom,\n    set_desired_chance,\n    set_budget_inputs,\n    setAutoOptimization,\n    setUserMatsValue,\n    setCumulativeGraph,\n    setDataSize,\n    setUseGridInput,\n    setNormalCounts,\n    setAdvCounts\n) {\n    const raw = localStorage.getItem(STORAGE_KEY)\n    if (!raw) return\n    const parsed = JSON.parse(raw)\n    if (parsed && typeof parsed === \"object\") {\n        if (Array.isArray(parsed.topGrid) && parsed.topGrid.length === TOP_ROWS && parsed.topGrid[0]?.length === TOP_COLS) setTopGrid(parsed.topGrid)\n        if (Array.isArray(parsed.bottomGrid) && parsed.bottomGrid.length === BOTTOM_ROWS && parsed.bottomGrid[0]?.length === BOTTOM_COLS)\n            setBottomGrid(parsed.bottomGrid)\n        if (typeof parsed.adv_hone_strategy === \"string\") set_adv_hone_strategy_change(parsed.adv_hone_strategy)\n        if (typeof parsed.express_event === \"boolean\") set_express_event(parsed.express_event)\n        if (Array.isArray(parsed.prev_checked_arr) && parsed.prev_checked_arr.length === TOP_COLS) set_prev_checked_arr(parsed.prev_checked_arr)\n        if (Array.isArray(parsed.prev_checked_arr_bottom) && parsed.prev_checked_arr_bottom.length === BOTTOM_COLS)\n            set_prev_checked_arr_bottom(parsed.prev_checked_arr_bottom)\n        if (typeof parsed.desired_chance === \"string\") set_desired_chance(parsed.desired_chance)\n        if (parsed.budget_inputs && typeof parsed.budget_inputs === \"object\") set_budget_inputs(parsed.budget_inputs)\n        if (typeof parsed.autoOptimization === \"boolean\") setAutoOptimization(parsed.autoOptimization)\n        if (parsed.userMatsValue && typeof parsed.userMatsValue === \"object\") setUserMatsValue(parsed.userMatsValue)\n        if (typeof parsed.cumulativeGraph === \"boolean\") setCumulativeGraph(parsed.cumulativeGraph)\n        if (typeof parsed.dataSize === \"string\") setDataSize(parsed.dataSize)\n        if (typeof parsed.useGridInput === \"boolean\") setUseGridInput(parsed.useGridInput)\n        if (Array.isArray(parsed.normalCounts) && parsed.normalCounts.length === 2 && parsed.normalCounts[0]?.length === TOP_COLS)\n            setNormalCounts(parsed.normalCounts)\n        if (Array.isArray(parsed.advCounts) && parsed.advCounts.length === 2 && parsed.advCounts[0]?.length === BOTTOM_COLS) setAdvCounts(parsed.advCounts)\n    }\n}\n","/**\r\n * Helper functions for histogram data remapping when locking x-axis ranges\r\n *\r\n * Behavior:\r\n *  - If lockedMax === newMax -> return shallow copy (no remap)\r\n *  - Otherwise compute overlap between each incoming bucket interval [j*newBin, (j+1)*newBin)\r\n *    and each locked bucket interval [i*lockedBin, (i+1)*lockedBin) and distribute counts proportionally.\r\n *  - If lockedMax < newMax some incoming mass may fall beyond lockedMax; that mass is dropped.\r\n */\r\n\r\n/**\r\n * Remap a single series counts from newMax -> lockedMax using bucket overlap fractions\r\n */\r\nexport function remapCountsSingleSeries(countsNew: number[], newMax: number, lockedMax: number): number[] {\r\n    const n = countsNew.length\r\n    if (n === 0) return []\r\n\r\n    // defensive numeric guards\r\n    if (!isFinite(newMax) || newMax <= 0) {\r\n        // cannot reason about bin sizes; return shallow copy\r\n        return countsNew.slice()\r\n    }\r\n    if (!isFinite(lockedMax) || lockedMax <= 0) {\r\n        // locked range is non-positive: nothing mapped\r\n        return new Array(n).fill(0)\r\n    }\r\n\r\n    // bin widths\r\n    const newBin = newMax / n\r\n    const lockedBin = lockedMax / n\r\n\r\n    // identical ranges -> copy\r\n    if (lockedMax === newMax) {\r\n        return countsNew.slice()\r\n    }\r\n\r\n    const out = new Array(n).fill(0)\r\n\r\n    // For each incoming bucket j, distribute countsNew[j] across locked buckets i that overlap.\r\n    for (let j = 0; j < n; j++) {\r\n        const c = countsNew[j] ?? 0\r\n        if (c === 0) continue\r\n\r\n        const bucketStartNew = j * newBin\r\n        const bucketEndNew = (j + 1) * newBin\r\n\r\n        // If bucket is entirely to the right of lockedMax, skip (truncated)\r\n        if (bucketStartNew >= lockedMax) continue\r\n\r\n        // Determine locked bucket indices that can overlap this incoming bucket.\r\n        // compute conservative bounds so we loop only over plausible i's\r\n        const iStart = Math.floor(bucketStartNew / lockedBin)\r\n        const iEnd = Math.floor((Math.min(bucketEndNew, lockedMax) - 1e-12) / lockedBin) // inclusive bound\r\n        const i0 = Math.max(0, iStart)\r\n        const i1 = Math.min(n - 1, iEnd)\r\n\r\n        // If i1 < i0 it's still possible they overlap partially within first/last locked bucket,\r\n        // so clamp and fallback to checking a small neighborhood\r\n        if (i1 < i0) {\r\n            // fallback: check the locked bucket that contains bucketStartNew (if in range)\r\n            const maybeI = Math.floor(bucketStartNew / lockedBin)\r\n            const ii = Math.min(Math.max(0, maybeI), n - 1)\r\n            const lockedStart = ii * lockedBin\r\n            const lockedEnd = (ii + 1) * lockedBin\r\n            const left = Math.max(bucketStartNew, lockedStart)\r\n            const right = Math.min(bucketEndNew, lockedEnd, lockedMax)\r\n            const overlap = Math.max(0, right - left)\r\n            if (overlap > 0) {\r\n                out[ii] += c * (overlap / newBin)\r\n            }\r\n            continue\r\n        }\r\n\r\n        for (let i = i0; i <= i1; i++) {\r\n            const lockedStart = i * lockedBin\r\n            const lockedEnd = (i + 1) * lockedBin\r\n            // restrict right to lockedMax so we drop any portion past lockedMax\r\n            const left = Math.max(bucketStartNew, lockedStart)\r\n            const right = Math.min(bucketEndNew, lockedEnd, lockedMax)\r\n            const overlap = Math.max(0, right - left)\r\n            if (overlap <= 0) continue\r\n            const fraction = overlap / newBin\r\n            out[i] += c * fraction\r\n        }\r\n    }\r\n\r\n    return out\r\n}\r\n\r\n/**\r\n * Remap all series given arrays\r\n */\r\nexport function remapCountsToLockedXAxis(countsArr: number[][], newMaxsArr: number[] | null | undefined, lockedMaxsArr: number[] | null): number[][] {\r\n    if (!countsArr) return countsArr\r\n    if (!lockedMaxsArr) return countsArr\r\n\r\n    const nSeries = countsArr.length\r\n    const out: number[][] = Array.from({ length: nSeries }, () => [])\r\n\r\n    for (let i = 0; i < nSeries; i++) {\r\n        const countsNew = countsArr[i] || []\r\n        const newMax = newMaxsArr && typeof newMaxsArr[i] === \"number\" ? newMaxsArr[i] : 1\r\n        const lockedMax = typeof lockedMaxsArr[i] === \"number\" ? lockedMaxsArr[i] : newMax\r\n\r\n        // Use remapping routine for all cases; it will handle lockedMax > newMax (expansion),\r\n        // lockedMax < newMax (compression + truncation) and equality (copy).\r\n        out[i] = remapCountsSingleSeries(countsNew, newMax, lockedMax)\r\n    }\r\n\r\n    return out\r\n}\r\n","// Equipment types for armor pieces\nexport const EQUIPMENT_TYPES = [\"Helmet\", \"Shoulder\", \"Chest\", \"Pants\", \"Gloves\", \"Weapon\"]\n\n// TypeScript interfaces\nexport interface Upgrade {\n    is_normal_honing: boolean\n    prob_dist: number[]\n    original_prob_dist: number[]\n    base_chance: number\n    costs: number[]\n    one_juice_cost: number\n    adv_juice_cost: number[]\n    special_cost: number\n    values: number[]\n    prob_dist_len: number\n    is_weapon: boolean\n    artisan_rate: number\n    tap_offset: number\n    upgrade_plus_num: number\n    special_value: number\n    equipment_type?: string // Added for equipment type\n    is_finished?: boolean // Track if upgrade is completed\n    completion_order?: number // Track order of completion\n    current_artisan?: number // Track current artisan for this upgrade\n    taps_so_far?: number // Number of taps attempted so far\n    juice_taps_so_far?: number // Number of taps with juice so far\n    free_taps_so_far?: number // Number of free taps so far\n    use_juice?: boolean // Whether juice is currently enabled for this upgrade\n    cumulative_chance?: number // Cumulative chance of success for normal honing\n    other_prob_dist?: number[] // Probability distribution for the other strategy (for advanced honing)\n}\n\nexport function sortedUpgrades(upgradeArr: Upgrade[]) {\n    let out = [...upgradeArr]\n    out.sort((a, b) => {\n        // Unfinished normal honing upgrades first\n        if (a.is_finished < b.is_finished) {\n            return -1\n        }\n        if (a.is_finished > b.is_finished) {\n            return 1\n        }\n        if (a.is_normal_honing < b.is_normal_honing) {\n            return 1\n        }\n        if (a.is_normal_honing > b.is_normal_honing) {\n            return -1\n        }\n\n        // Then finished upgrades by completion order\n        if (a.is_finished && b.is_finished) {\n            return (a.completion_order || 0) - (b.completion_order || 0)\n        }\n        if (!a.is_finished && !b.is_finished) {\n            if (a.upgrade_plus_num < b.upgrade_plus_num) {\n                return -1\n            }\n            if (a.upgrade_plus_num > b.upgrade_plus_num) {\n                return 1\n            }\n            return EQUIPMENT_TYPES.findIndex((value, _) => a.equipment_type == value) - EQUIPMENT_TYPES.findIndex((value, _) => b.equipment_type == value)\n        }\n        return 0\n    })\n    return out\n}\n\n// Helper function to get the next unfinished upgrade index\nexport function getNextUnfinishedIndex(upgradeArr: Upgrade[], excludeIndex?: number): number {\n    let first_try = upgradeArr.findIndex((z) => z == sortedUpgrades(upgradeArr).find((upg, i) => !upg.is_finished && i > excludeIndex))\n    console.log(first_try)\n    if (first_try < 0) {\n        return upgradeArr.findIndex((z) => z == sortedUpgrades(upgradeArr).find((upg, i) => !upg.is_finished && i !== excludeIndex))\n    }\n    return first_try\n}\n\n// Helper function to calculate tap record costs\nexport function calculateTapRecordCosts(upgrade: Upgrade) {\n    const costs = new Array(10).fill(0)\n    const taps = upgrade.taps_so_far ?? 0\n    const juiceTaps = upgrade.juice_taps_so_far ?? 0\n    const freeTaps = upgrade.free_taps_so_far ?? 0\n\n    // Regular costs multiplied by taps\n    for (let i = 0; i < 7; i++) {\n        costs[i] = upgrade.costs[i] * taps\n    }\n\n    // Juice costs\n    if (juiceTaps > 0) {\n        const juiceCost = upgrade.one_juice_cost * juiceTaps\n        if (upgrade.is_weapon) {\n            costs[8] = juiceCost // Weapons add to 9th slot (index 8)\n        } else {\n            costs[7] = juiceCost // Armors add to 8th slot (index 7)\n        }\n    }\n\n    // Free tap costs\n\n    costs[9] = upgrade.special_cost * freeTaps\n\n    return costs\n}\n\nexport function calculateCurrentChance(upgrade: Upgrade) {\n    if (!upgrade.is_normal_honing) return 0\n    const baseChance = upgrade.base_chance\n    const minCount = Math.min(upgrade.taps_so_far, 10)\n    const currentChance = baseChance + (baseChance / 10) * minCount\n    return Math.max(0, Math.min(1, upgrade.current_artisan >= 1 ? 1 : upgrade.use_juice ? currentChance + upgrade.base_chance : currentChance))\n}\n\nexport function updateCumulativeChance(upgrade: Upgrade, attemptChance: number) {\n    if (!upgrade.is_normal_honing) return\n\n    // Initialize cumulative chance if it doesn't exist\n    if (upgrade.cumulative_chance === undefined) {\n        upgrade.cumulative_chance = 0\n    }\n\n    // Update cumulative chance: add the probability of succeeding on this attempt\n    // given that all previous attempts failed\n    const previousFailureProbability = 1 - upgrade.cumulative_chance\n    upgrade.cumulative_chance += attemptChance * previousFailureProbability\n\n    // Ensure it doesn't exceed 1\n    upgrade.cumulative_chance = Math.min(1, upgrade.cumulative_chance)\n}\n\nexport function getTapCountRange(upgrade: Upgrade) {\n    if (upgrade.is_normal_honing) return null\n\n    // Use other strategy's probability distribution if juice is ticked\n    const probDistToUse = upgrade.use_juice && upgrade.other_prob_dist ? upgrade.other_prob_dist : upgrade.prob_dist\n\n    const range = `${upgrade.tap_offset} - ${upgrade.tap_offset + probDistToUse.length}`\n    const isUsingOtherStrategy = upgrade.use_juice && upgrade.other_prob_dist\n\n    return { range, isUsingOtherStrategy }\n}\n\n/**\n * Convert ticks (boolean grid) to counts (integer array)\n * Mirrors the Rust implementation in helpers.rs\n *\n * @param ticks - 6xN boolean array where:\n *   - rows 0-4 represent armor pieces (Helmet, Shoulder, Chest, Pants, Glove)\n *   - row 5 represents weapon\n * @returns 2xN array where:\n *   - [0][i] = sum of ticks[0..4][i] (armor count for level i)\n *   - [1][i] = ticks[5][i] ? 1 : 0 (weapon count for level i)\n */\nexport function ticksToCounts(ticks: boolean[][]): number[][] {\n    if (ticks.length === 0 || ticks[0].length === 0) {\n        return [[], []]\n    }\n\n    const cols = ticks[0].length\n    const out: number[][] = [[], []]\n\n    for (let i = 0; i < cols; i++) {\n        // Sum ticks[0..4][i] for armor count\n        let armorCount = 0\n        for (let row = 0; row < 5; row++) {\n            if (ticks[row] && ticks[row][i]) {\n                armorCount++\n            }\n        }\n        out[0][i] = armorCount\n\n        // ticks[5][i] as 0/1 for weapon count\n        out[1][i] = ticks[5] && ticks[5][i] ? 1 : 0\n    }\n\n    return out\n}\n\n/**\n * Convert counts (integer array) to ticks (boolean grid)\n * Inverse of ticksToCounts - fills checkboxes from top\n *\n * @param counts - 2xN array where:\n *   - [0][i] = armor count for level i (max 5)\n *   - [1][i] = weapon count for level i (max 1)\n * @returns 6xN boolean array\n */\nexport function countsToTicks(counts: number[][]): boolean[][] {\n    if (counts.length < 2 || counts[0].length === 0) {\n        return Array.from({ length: 6 }, () => [])\n    }\n\n    const cols = counts[0].length\n    const ticks: boolean[][] = Array.from({ length: 6 }, () => Array(cols).fill(false))\n\n    for (let i = 0; i < cols; i++) {\n        const armorCount = Math.min(5, Math.max(0, counts[0][i] || 0))\n        const weaponCount = Math.min(1, Math.max(0, counts[1][i] || 0))\n\n        // Fill armor checkboxes from top\n        for (let row = 0; row < armorCount; row++) {\n            ticks[row][i] = true\n        }\n\n        // Fill weapon checkbox if needed\n        if (weaponCount > 0) {\n            ticks[5][i] = true\n        }\n    }\n\n    return ticks\n}\n","import { SpawnWorker } from \"../../worker_setup.ts\"\nimport { INPUT_LABELS } from \"./constants.ts\"\nimport { ticksToCounts } from \"./utils.ts\"\n\nexport function buildPayload({\n    topGrid,\n    bottomGrid,\n    budget_inputs,\n    adv_hone_strategy,\n    express_event,\n    bucketCount,\n    autoOptimization,\n    userMatsValue,\n    dataSize,\n    useGridInput = true,\n    normalCounts,\n    advCounts,\n}: {\n    topGrid: boolean[][]\n    bottomGrid: boolean[][]\n    budget_inputs: any\n    adv_hone_strategy: string\n    express_event: boolean\n    bucketCount: string\n    autoOptimization: boolean\n    userMatsValue: any\n    dataSize: string\n    useGridInput?: boolean\n    normalCounts?: number[][]\n    advCounts?: number[][]\n}) {\n    const payload: any = {\n        budget: ((input) => Object.entries(input).map(([, v]) => Math.round(Number(v))))(budget_inputs),\n        adv_hone_strategy: adv_hone_strategy,\n        express_event: express_event,\n        bucket_count: Math.max(2, Math.min(1000, Math.floor(Number(bucketCount) || 2))),\n        user_mats_value: autoOptimization\n            ? INPUT_LABELS.slice(0, 7).map((_) => 0.0)\n            : INPUT_LABELS.slice(0, 7).map((label) => parseFloat(userMatsValue[label] || \"0\")),\n        data_size: Math.max(1000, Math.floor(Number(dataSize) || 0)),\n    }\n\n    if (useGridInput) {\n        // Use the traditional tick-based approach\n        payload.normal_hone_ticks = topGrid\n        payload.adv_hone_ticks = bottomGrid\n    } else {\n        // Use direct counts approach\n        payload.normal_counts = normalCounts || ticksToCounts(topGrid)\n        payload.adv_counts = advCounts || ticksToCounts(bottomGrid)\n    }\n\n    return payload\n}\n\nexport function createStartCancelableWorker({\n    costWorkerRef,\n    chanceWorkerRef,\n    averageCostWorkerRef,\n    parserWorkerRef,\n    setCostToChanceBusy,\n    setChanceToCostBusy,\n    setAverageCostBusy,\n    setParserBusy,\n    set_chance_result,\n    set_cost_result,\n    setAverageCosts,\n    setUpgradeArr,\n    setCachedChanceGraphData,\n    setCachedCostGraphData,\n}: {\n    costWorkerRef: React.MutableRefObject<Worker | null>\n    chanceWorkerRef: React.MutableRefObject<Worker | null>\n    averageCostWorkerRef: React.MutableRefObject<Worker | null>\n    parserWorkerRef: React.MutableRefObject<Worker | null>\n    setCostToChanceBusy: React.Dispatch<React.SetStateAction<boolean>>\n    setChanceToCostBusy: React.Dispatch<React.SetStateAction<boolean>>\n    setAverageCostBusy: React.Dispatch<React.SetStateAction<boolean>>\n    setParserBusy: React.Dispatch<React.SetStateAction<boolean>>\n    set_chance_result: React.Dispatch<React.SetStateAction<any>>\n    set_cost_result: React.Dispatch<React.SetStateAction<any>>\n    setAverageCosts: React.Dispatch<React.SetStateAction<number[] | null>>\n    setUpgradeArr: React.Dispatch<React.SetStateAction<any[]>>\n    setCachedChanceGraphData: React.Dispatch<React.SetStateAction<{ hist_counts?: any; hist_mins?: any; hist_maxs?: any } | null>>\n    setCachedCostGraphData: React.Dispatch<React.SetStateAction<{ hist_counts?: any; hist_mins?: any; hist_maxs?: any } | null>>\n}) {\n    return (which_one: \"CostToChance\" | \"ChanceToCost\" | \"AverageCost\" | \"ParserUnified\", payload: any) => {\n        if (which_one === \"CostToChance\") {\n            // terminate previous\n            if (costWorkerRef.current) {\n                try {\n                    costWorkerRef.current.terminate()\n                } catch (e) {\n                    /* ignore */\n                }\n                costWorkerRef.current = null\n            }\n            setCostToChanceBusy(true)\n            // Clear text results but preserve graph data\n            set_chance_result(null)\n\n            const { worker, promise } = SpawnWorker(payload, which_one)\n            costWorkerRef.current = worker\n\n            promise\n                .then((res) => {\n                    // only set if this worker is still the current one\n                    if (costWorkerRef.current === worker) {\n                        set_chance_result(res)\n                        // Cache graph data for future use\n                        if (res && typeof res === \"object\" && res !== null && \"hist_counts\" in res) {\n                            const typedRes = res as { hist_counts: any; hist_mins: any; hist_maxs: any }\n                            setCachedChanceGraphData({\n                                hist_counts: typedRes.hist_counts,\n                                hist_mins: typedRes.hist_mins,\n                                hist_maxs: typedRes.hist_maxs,\n                            })\n                        }\n                    }\n                })\n                .catch((err) => {\n                    console.error(\"Worker error\", err)\n                    if (costWorkerRef.current === worker) {\n                        set_chance_result({ error: String(err) })\n                    }\n                })\n                .finally(() => {\n                    // cleanup if this worker is the current one\n                    if (costWorkerRef.current === worker) {\n                        try {\n                            worker.terminate()\n                        } catch (e) {\n                            /* ignore */\n                        }\n                        costWorkerRef.current = null\n                        setCostToChanceBusy(false)\n                    }\n                })\n        } else if (which_one === \"ChanceToCost\") {\n            // ChanceToCost\n            if (chanceWorkerRef.current) {\n                try {\n                    chanceWorkerRef.current.terminate()\n                } catch (e) {\n                    /* ignore */\n                }\n                chanceWorkerRef.current = null\n            }\n            setChanceToCostBusy(true)\n            // Clear text results but preserve graph data\n            set_cost_result(null)\n\n            const { worker, promise } = SpawnWorker(payload, which_one)\n            chanceWorkerRef.current = worker\n\n            promise\n                .then((res) => {\n                    if (chanceWorkerRef.current === worker) {\n                        set_cost_result(res)\n                        // Cache graph data for future use\n                        if (res && typeof res === \"object\" && res !== null && \"hist_counts\" in res) {\n                            const typedRes = res as { hist_counts: any; hist_mins: any; hist_maxs: any }\n                            setCachedCostGraphData({\n                                hist_counts: typedRes.hist_counts,\n                                hist_mins: typedRes.hist_mins,\n                                hist_maxs: typedRes.hist_maxs,\n                            })\n                        }\n                    }\n                })\n                .catch((err) => {\n                    console.error(\"Worker error\", err)\n                    if (chanceWorkerRef.current === worker) {\n                        set_cost_result({ error: String(err) })\n                    }\n                })\n                .finally(() => {\n                    if (chanceWorkerRef.current === worker) {\n                        try {\n                            worker.terminate()\n                        } catch (e) {\n                            /* ignore */\n                        }\n                        chanceWorkerRef.current = null\n                        setChanceToCostBusy(false)\n                    }\n                })\n        } else if (which_one === \"AverageCost\") {\n            // terminate previous\n            if (averageCostWorkerRef.current) {\n                try {\n                    averageCostWorkerRef.current.terminate()\n                } catch (e) {\n                    /* ignore */\n                }\n                averageCostWorkerRef.current = null\n            }\n            setAverageCostBusy(true)\n            setAverageCosts(null)\n\n            const { worker, promise } = SpawnWorker(payload, which_one)\n            averageCostWorkerRef.current = worker\n\n            promise\n                .then((res) => {\n                    if (averageCostWorkerRef.current === worker) {\n                        if (res && (res as any).average_costs) {\n                            setAverageCosts((res as any).average_costs)\n                        }\n                    }\n                })\n                .catch((err) => {\n                    console.error(\"AverageCost worker error\", err)\n                    if (averageCostWorkerRef.current === worker) {\n                        setAverageCosts(null)\n                    }\n                })\n                .finally(() => {\n                    if (averageCostWorkerRef.current === worker) {\n                        try {\n                            worker.terminate()\n                        } catch (e) {\n                            /* ignore */\n                        }\n                        averageCostWorkerRef.current = null\n                        setAverageCostBusy(false)\n                    }\n                })\n        } else if (which_one === \"ParserUnified\") {\n            // terminate previous\n            if (parserWorkerRef.current) {\n                try {\n                    parserWorkerRef.current.terminate()\n                } catch (e) {\n                    /* ignore */\n                }\n                parserWorkerRef.current = null\n            }\n            setParserBusy(true)\n            setUpgradeArr([])\n\n            const { worker, promise } = SpawnWorker(payload, which_one)\n            parserWorkerRef.current = worker\n\n            promise\n                .then((res) => {\n                    if (parserWorkerRef.current === worker) {\n                        if (res && (res as any).upgrades) {\n                            setUpgradeArr((res as any).upgrades)\n                        }\n                    }\n                })\n                .catch((err) => {\n                    console.error(\"Parser worker error\", err)\n                    if (parserWorkerRef.current === worker) {\n                        setUpgradeArr([])\n                    }\n                })\n                .finally(() => {\n                    if (parserWorkerRef.current === worker) {\n                        try {\n                            worker.terminate()\n                        } catch (e) {\n                            /* ignore */\n                        }\n                        parserWorkerRef.current = null\n                        setParserBusy(false)\n                    }\n                })\n        }\n    }\n}\n\nexport function createHandleCallWorker({\n    startCancelableWorker,\n    buildPayload,\n}: {\n    startCancelableWorker: (_which_one: \"CostToChance\" | \"ChanceToCost\" | \"AverageCost\" | \"ParserUnified\", _payload: any) => void\n    buildPayload: () => any\n}) {\n    return async (which_one: string) => {\n        // keep the old behavior for manual button calls but make it cancel previous worker using startCancelableWorker\n        const payload = buildPayload()\n        if (which_one === \"CostToChance\") startCancelableWorker(\"CostToChance\", payload)\n        else startCancelableWorker(\"ChanceToCost\", payload)\n    }\n}\n\nexport function createDebounceEffects({\n    debounceTimerRef1,\n    debounceTimerRef2,\n    startCancelableWorker,\n    buildPayload,\n}: {\n    debounceTimerRef1: React.MutableRefObject<number | null>\n    debounceTimerRef2: React.MutableRefObject<number | null>\n    startCancelableWorker: (_which_one: \"CostToChance\" | \"ChanceToCost\", _payload: any) => void\n    buildPayload: () => any\n}) {\n    return {\n        // When budget or grids or strategy change -> run CostToChance (budget -> cost->chance)\n        createCostToChanceEffect: (_deps: any[]) => {\n            return () => {\n                // clear existing timer\n                if (debounceTimerRef1.current) {\n                    window.clearTimeout(debounceTimerRef1.current)\n                    debounceTimerRef1.current = null\n                }\n                // start new delayed work\n                debounceTimerRef1.current = window.setTimeout(() => {\n                    const payload = buildPayload()\n                    startCancelableWorker(\"CostToChance\", payload)\n                    debounceTimerRef1.current = null\n                }, 100) // 100ms debounce\n            }\n        },\n\n        // When desired chance or grids or strategy change -> run ChanceToCost (chance -> cost)\n        createChanceToCostEffect: (_deps: any[]) => {\n            return () => {\n                if (debounceTimerRef2.current) {\n                    window.clearTimeout(debounceTimerRef2.current)\n                    debounceTimerRef2.current = null\n                }\n                debounceTimerRef2.current = window.setTimeout(() => {\n                    const payload = buildPayload()\n                    // console.log(payload)\n                    startCancelableWorker(\"ChanceToCost\", payload)\n                    debounceTimerRef2.current = null\n                }, 100)\n            }\n        },\n    }\n}\n","import React, { useState, useEffect } from 'react';\nimport './separator.css';\n\n\ntype Page = 'chance-to-cost' | 'cost-to-chance' | 'gamba';\n\ntype SeparatorProps = {\n    activePage: Page;\n    onPageChange: (_page: Page) => void;\n};\n\nexport default function Separator({ activePage, onPageChange }: SeparatorProps) {\n    const [_clickedButton, setClickedButton] = useState<Page | null>(activePage);\n\n    useEffect(() => {\n        setClickedButton(activePage);\n    }, [activePage]);\n\n    const handleButtonClick = (page: Page) => {\n        onPageChange(page);\n        setClickedButton(page);\n    };\n\n    const getSeparatorClass = () => {\n        if (activePage === 'chance-to-cost') return 'hf-separator chance-active';\n        if (activePage === 'cost-to-chance') return 'hf-separator budget-active';\n        if (activePage === 'gamba') return 'hf-separator gamba-active';\n        return 'hf-separator';\n    };\n\n    const getButtonClass = (page: Page) => {\n        const baseClass = 'hf-btn';\n        if (activePage === page) {\n            if (page === 'chance-to-cost') return `${baseClass} chance-selected`;\n            if (page === 'cost-to-chance') return `${baseClass} budget-selected`;\n            if (page === 'gamba') return `${baseClass} gamba-selected`;\n        }\n        return baseClass;\n    };\n\n    return (\n        <div className={getSeparatorClass()}>\n            <button\n                className={getButtonClass('chance-to-cost')}\n                onClick={() => handleButtonClick('chance-to-cost')}\n            >\n                <span className=\"hf-label\">Chance mode</span>\n                <div className=\"hf-help\">\n                    I want to have x% chance to pass, how much mats will I need?\n                </div>\n            </button>\n\n            <button\n                className={getButtonClass('cost-to-chance')}\n                onClick={() => handleButtonClick('cost-to-chance')}\n            >\n                <span className=\"hf-label\">Budget mode</span>\n                <div className=\"hf-help\">\n                    I have this much mats, what are my odds of success?\n                </div>\n            </button>\n\n            <button\n                className={getButtonClass('gamba')}\n                onClick={() => handleButtonClick('gamba')}\n            >\n                <span className=\"hf-label\">Gamba simulator</span>\n                <div className=\"hf-help\">Simulate a honing session without hurting your wallet or your soul</div>\n            </button>\n        </div>\n    );\n}\n","import React from 'react'\r\n\r\nexport type TooltipType = 'separator' | 'upgrade'\r\n\r\nexport interface TooltipState {\r\n    visible: boolean\r\n    type: TooltipType | null\r\n    x: number\r\n    y: number\r\n    content: string | null\r\n    upgradeData?: {\r\n        upgrade: any\r\n        costLabels: string[]\r\n        tapRecordCosts: number[]\r\n    } | null\r\n}\r\n\r\nexport function createTooltipHandlers(\r\n    setTooltip: React.Dispatch<React.SetStateAction<TooltipState>>\r\n) {\r\n    const showSeparatorTooltip = (text: string, x: number, y: number) => {\r\n        setTooltip({\r\n            visible: true,\r\n            type: 'separator',\r\n            x: x + 10,\r\n            y: y - 10,\r\n            content: text,\r\n            upgradeData: null\r\n        })\r\n    }\r\n\r\n    const showUpgradeTooltip = (\r\n        upgrade: any,\r\n        costLabels: string[],\r\n        tapRecordCosts: number[],\r\n        x: number,\r\n        y: number\r\n    ) => {\r\n        setTooltip({\r\n            visible: true,\r\n            type: 'upgrade',\r\n            x: x + 10,\r\n            y: y,\r\n            content: null,\r\n            upgradeData: {\r\n                upgrade,\r\n                costLabels,\r\n                tapRecordCosts\r\n            }\r\n        })\r\n    }\r\n\r\n    const hideTooltip = () => {\r\n        setTooltip(prev => ({ ...prev, visible: false }))\r\n    }\r\n\r\n    const updateTooltipPosition = (x: number, y: number) => {\r\n        setTooltip(prev => ({\r\n            ...prev,\r\n            x: x + 10,\r\n            y: y - 10\r\n        }))\r\n    }\r\n\r\n    return {\r\n        showSeparatorTooltip,\r\n        showUpgradeTooltip,\r\n        hideTooltip,\r\n        updateTooltipPosition\r\n    }\r\n}\r\n\r\nexport function renderTooltip(tooltip: TooltipState, mainScale: number = 1, zoomCompensation: number = 1) {\r\n    if (!tooltip.visible) return null\r\n\r\n    // Combine main scale and zoom compensation for final tooltip scale\r\n    const finalScale = mainScale * zoomCompensation\r\n\r\n    const tooltipStyle: React.CSSProperties = {\r\n        position: 'fixed',\r\n        left: tooltip.x,\r\n        top: tooltip.y,\r\n        backgroundColor: 'var(--bg-tertiary)',\r\n        color: 'var(--text-primary)',\r\n        padding: tooltip.type === 'upgrade' ? '12px 16px' : '8px 12px',\r\n        borderRadius: 'var(--border-radius-small)',\r\n        fontSize: 'var(--font-size-sm)',\r\n        fontWeight: 'var(--font-weight-normal)',\r\n        border: '1px solid var(--border-secondary)',\r\n        boxShadow: '0 4px 12px rgba(0, 0, 0, 0.3)',\r\n        zIndex: 10000,\r\n        pointerEvents: 'none',\r\n        opacity: tooltip.visible ? 1 : 0,\r\n        transition: 'opacity 0.1s ease-in-out',\r\n        minWidth: tooltip.type === 'upgrade' ? '300px' : 'auto',\r\n        maxWidth: tooltip.type === 'upgrade' ? '400px' : 'auto',\r\n        whiteSpace: tooltip.type === 'separator' ? 'nowrap' : 'normal',\r\n        transform: `scale(${finalScale})`,\r\n        transformOrigin: 'top left'\r\n    }\r\n\r\n    if (tooltip.type === 'separator') {\r\n        return (\r\n            <div style={tooltipStyle}>\r\n                {tooltip.content}\r\n            </div>\r\n        )\r\n    }\r\n\r\n    if (tooltip.type === 'upgrade' && tooltip.upgradeData) {\r\n        const { upgrade, costLabels, tapRecordCosts } = tooltip.upgradeData\r\n\r\n        const leftColumnStyle: React.CSSProperties = {\r\n            display: 'flex',\r\n            flexDirection: 'column',\r\n            gap: '4px',\r\n            marginRight: '16px',\r\n            width: '35%',\r\n            minWidth: '120px'\r\n        }\r\n\r\n        const rightColumnStyle: React.CSSProperties = {\r\n            display: 'flex',\r\n            flexDirection: 'column',\r\n            gap: '2px',\r\n            width: '65%',\r\n            minWidth: '180px'\r\n        }\r\n\r\n        const containerStyle: React.CSSProperties = {\r\n            display: 'flex',\r\n            flexDirection: 'row'\r\n        }\r\n\r\n        return (\r\n            <div style={tooltipStyle}>\r\n                <div style={containerStyle}>\r\n                    <div style={leftColumnStyle}>\r\n                        <div><strong>{upgrade.is_normal_honing ? '+' : 'Adv +'}{upgrade.upgrade_plus_num + (upgrade.is_normal_honing ? 1 : 0)} {upgrade.equipment_type}</strong></div>\r\n\r\n                        {upgrade.is_finished && upgrade.current_artisan && (\r\n                            <div>Artisan: {(upgrade.current_artisan * 100).toFixed(2)}%</div>\r\n                        )}\r\n                        <div>Taps: {upgrade.taps_so_far ?? 0}</div>\r\n                        <div>Juice Taps: {upgrade.juice_taps_so_far ?? 0}</div>\r\n                        <div>Free Taps: {upgrade.free_taps_so_far ?? 0}</div>\r\n                        {upgrade.is_normal_honing && upgrade.is_finished && (\r\n                            <div>In a room of 100 people, you are less lucky than {((upgrade.cumulative_chance || 0) * 100).toFixed(0)} of them.</div>\r\n                        )}\r\n                    </div>\r\n                    <div style={rightColumnStyle}>\r\n                        <div><strong>Costs so far(excluding unlock):</strong></div>\r\n                        {costLabels.map((label, index) => (\r\n                            <div key={index}>\r\n                                {label}: {tapRecordCosts[index].toLocaleString()}\r\n                            </div>\r\n                        ))}\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        )\r\n    }\r\n\r\n    return null\r\n}\r\n","import { TOP_ROWS, TOP_COLS, BOTTOM_ROWS, BOTTOM_COLS } from \"./constants.ts\"\n\nexport function coordsToCell(ref: HTMLDivElement | null, clientX: number, clientY: number, rows: number, cols: number) {\n    if (!ref) return { r: 0, c: 0 }\n    const rect = ref.getBoundingClientRect()\n    const x = Math.max(0, Math.min(clientX - rect.left, rect.width - 1))\n    const y = Math.max(0, Math.min(clientY - rect.top, rect.height - 1))\n    let cellW = rect.width / cols\n    let cellH = rect.height / rows\n    const c = Math.floor(x / cellW)\n    const r = Math.floor(y / cellH)\n    return { r: Math.max(0, Math.min(rows - 1, r)), c: Math.max(0, Math.min(cols - 1, c)) }\n}\n\nexport function GridMouseDownLogic({\n    topGridRef,\n    bottomGridRef,\n    marqueeRef,\n    topGrid,\n    bottomGrid,\n    setMarquee,\n}: {\n    topGridRef: React.RefObject<HTMLDivElement | null>\n    bottomGridRef: React.RefObject<HTMLDivElement | null>\n    marqueeRef: React.MutableRefObject<any>\n    topGrid: boolean[][]\n    bottomGrid: boolean[][]\n    setMarquee: React.Dispatch<React.SetStateAction<any>>\n}) {\n    return (grid: \"top\" | \"bottom\", e: React.MouseEvent) => {\n        e.preventDefault()\n        const ref = grid === \"top\" ? topGridRef.current : bottomGridRef.current\n        const rows = grid === \"top\" ? TOP_ROWS : BOTTOM_ROWS\n        const cols = grid === \"top\" ? TOP_COLS : BOTTOM_COLS\n        const { r, c } = coordsToCell(ref, e.clientX, e.clientY, rows, cols)\n        const initialState = grid === \"top\" ? topGrid[r][c] : bottomGrid[r][c]\n        const next = {\n            active: true,\n            grid,\n            startR: r,\n            startC: c,\n            endR: r,\n            endC: c,\n            startClientX: e.clientX,\n            startClientY: e.clientY,\n            endClientX: e.clientX,\n            endClientY: e.clientY,\n            initialState,\n        }\n        setMarquee(next)\n        marqueeRef.current = next\n    }\n}\n\nexport function mouseMoveLogic(\n    ev: MouseEvent,\n    marqueeRef: React.MutableRefObject<any>,\n    topGridRef: React.RefObject<HTMLDivElement | null>,\n    bottomGridRef: React.RefObject<HTMLDivElement | null>,\n    setMarquee: React.Dispatch<React.SetStateAction<any>>\n) {\n    const m = marqueeRef.current\n    if (!m || !m.active || !m.grid) return\n    const grid = m.grid\n    const ref = grid === \"top\" ? topGridRef.current : bottomGridRef.current\n    const rows = grid === \"top\" ? TOP_ROWS : BOTTOM_ROWS\n    const cols = grid === \"top\" ? TOP_COLS : BOTTOM_COLS\n    const { r, c } = coordsToCell(ref, ev.clientX, ev.clientY, rows, cols)\n    setMarquee((prev: any) => ({ ...prev, endR: r, endC: c, endClientX: ev.clientX, endClientY: ev.clientY }))\n}\n\nexport function createMouseUpHandler({\n    marqueeRef,\n    topGridRef,\n    bottomGridRef,\n    setTopGrid,\n    setBottomGrid,\n    set_prev_checked_arr,\n    set_prev_checked_arr_bottom,\n    setMarquee,\n}: {\n    marqueeRef: React.MutableRefObject<any>\n    topGridRef: React.RefObject<HTMLDivElement | null>\n    bottomGridRef: React.RefObject<HTMLDivElement | null>\n    setTopGrid: React.Dispatch<React.SetStateAction<any>>\n    setBottomGrid: React.Dispatch<React.SetStateAction<any>>\n    set_prev_checked_arr: React.Dispatch<React.SetStateAction<boolean[]>>\n    set_prev_checked_arr_bottom: React.Dispatch<React.SetStateAction<boolean[]>>\n    setMarquee: React.Dispatch<React.SetStateAction<any>>\n}) {\n    return (ev: MouseEvent) => {\n        const m = marqueeRef.current\n        if (!m || !m.active || !m.grid) return\n        const { grid, startClientX, startClientY, endClientX, endClientY, initialState } = m\n        const ref = grid === \"top\" ? topGridRef.current : bottomGridRef.current\n        const rows = grid === \"top\" ? TOP_ROWS : BOTTOM_ROWS\n        const cols = grid === \"top\" ? TOP_COLS : BOTTOM_COLS\n        const startCell = coordsToCell(ref, startClientX, startClientY, rows, cols)\n        const endCell = coordsToCell(ref, endClientX || ev.clientX, endClientY || ev.clientY, rows, cols)\n        const r1 = Math.min(startCell.r, endCell.r)\n        const r2 = Math.max(startCell.r, endCell.r)\n        const c1 = Math.min(startCell.c, endCell.c)\n        const c2 = Math.max(startCell.c, endCell.c)\n        const setter = grid === \"top\" ? setTopGrid : setBottomGrid\n        setter((prev: any) => {\n            const copy = prev.map((row: any) => row.slice())\n            const newState = !initialState\n            for (let rr = r1; rr <= r2; rr++) {\n                for (let cc = c1; cc <= c2; cc++) {\n                    if (rr < copy.length && cc < copy[rr].length) copy[rr][cc] = newState\n                }\n            }\n\n            // Update column headers based on new state\n            if (grid === \"top\") {\n                set_prev_checked_arr((prev) => {\n                    const newArr = [...prev]\n                    for (let cc = c1; cc <= c2; cc++) {\n                        let allChecked = true\n                        for (let rr = 0; rr < rows; rr++) {\n                            if (!copy[rr][cc]) {\n                                allChecked = false\n                                break\n                            }\n                        }\n                        newArr[cc] = allChecked\n                    }\n                    return newArr\n                })\n            } else {\n                set_prev_checked_arr_bottom((prev) => {\n                    const newArr = [...prev]\n                    for (let cc = c1; cc <= c2; cc++) {\n                        let allChecked = true\n                        for (let rr = 0; rr < rows; rr++) {\n                            if (!copy[rr][cc]) {\n                                allChecked = false\n                                break\n                            }\n                        }\n                        newArr[cc] = allChecked\n                    }\n                    return newArr\n                })\n            }\n\n            return copy\n        })\n        setMarquee({\n            active: false,\n            grid: null,\n            startR: 0,\n            startC: 0,\n            endR: 0,\n            endC: 0,\n            startClientX: 0,\n            startClientY: 0,\n            endClientX: 0,\n            endClientY: 0,\n            initialState: false,\n        })\n    }\n}\n"],"names":["writeSettings","topGrid","bottomGrid","adv_hone_strategy","express_event","prev_checked_arr","prev_checked_arr_bottom","desired_chance","budget_inputs","autoOptimization","userMatsValue","cumulativeGraph","dataSize","useGridInput","normalCounts","advCounts","toSave","STORAGE_KEY","readSettings","setTopGrid","setBottomGrid","set_adv_hone_strategy_change","set_express_event","set_prev_checked_arr","set_prev_checked_arr_bottom","set_desired_chance","set_budget_inputs","setAutoOptimization","setUserMatsValue","setCumulativeGraph","setDataSize","setUseGridInput","setNormalCounts","setAdvCounts","raw","parsed","TOP_ROWS","_a","TOP_COLS","BOTTOM_ROWS","_b","BOTTOM_COLS","_c","_d","remapCountsSingleSeries","countsNew","newMax","lockedMax","n","newBin","lockedBin","out","j","c","bucketStartNew","bucketEndNew","iStart","iEnd","i0","i1","maybeI","ii","lockedStart","lockedEnd","left","right","overlap","i","fraction","remapCountsToLockedXAxis","countsArr","newMaxsArr","lockedMaxsArr","nSeries","EQUIPMENT_TYPES","sortedUpgrades","upgradeArr","a","b","value","_","getNextUnfinishedIndex","excludeIndex","first_try","z","upg","calculateCurrentChance","upgrade","baseChance","minCount","currentChance","updateCumulativeChance","attemptChance","previousFailureProbability","getTapCountRange","probDistToUse","range","isUsingOtherStrategy","ticksToCounts","ticks","cols","armorCount","row","countsToTicks","counts","weaponCount","buildPayload","bucketCount","payload","input","v","INPUT_LABELS","label","createStartCancelableWorker","costWorkerRef","chanceWorkerRef","averageCostWorkerRef","parserWorkerRef","setCostToChanceBusy","setChanceToCostBusy","setAverageCostBusy","setParserBusy","set_chance_result","set_cost_result","setAverageCosts","setUpgradeArr","setCachedChanceGraphData","setCachedCostGraphData","which_one","worker","promise","SpawnWorker","res","typedRes","err","Separator","activePage","onPageChange","_clickedButton","setClickedButton","useState","useEffect","handleButtonClick","page","getSeparatorClass","getButtonClass","baseClass","jsxs","jsx","createTooltipHandlers","setTooltip","text","x","y","costLabels","tapRecordCosts","prev","renderTooltip","tooltip","mainScale","zoomCompensation","finalScale","tooltipStyle","leftColumnStyle","rightColumnStyle","containerStyle","index","coordsToCell","ref","clientX","clientY","rows","rect","cellW","cellH","r","GridMouseDownLogic","topGridRef","bottomGridRef","marqueeRef","setMarquee","grid","e","initialState","next","mouseMoveLogic","ev","m","createMouseUpHandler","startClientX","startClientY","endClientX","endClientY","startCell","endCell","r1","r2","c1","c2","copy","newState","rr","cc","newArr","allChecked"],"mappings":"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"}